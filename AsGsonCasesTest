package automated.tests;

import java.io.BufferedReader;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.reflect.Modifier;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.codehaus.groovy.runtime.typehandling.GroovyCastException;

import automated.tests.annotations.AddImportsForTesting;
import automated.tests.annotations.AutomatedTests;
import automated.tests.annotations.CoverageTestsCases;
import automated.tests.annotations.DefaultParameterTestValue;
import automated.tests.annotations.DefaultTestFilename;
import automated.tests.annotations.DefaultTestValue;
import automated.tests.annotations.GenericTestType;
import automated.tests.annotations.SkipExceptions;
import automated.tests.annotations.SkipImportsForTesting;
import automated.tests.annotations.SkipTesting;
import automated.tests.annotations.TestMethodsInstance;
import automated.tests.annotations.data.AutomatedTestsCaseData;
import automated.tests.annotations.interfaces.IAutomatedTestsCases;
import automated.tests.annotations.interfaces.ICoverageTestsCases;
import automated.tests.data.AutomatedTestsStatisticsData;
import automated.tests.data.ConstructorsTestUnitData;
import automated.tests.data.MethodsTestUnitData;
import automated.tests.data.TestData;
import automated.tests.data.TestInfoValueData;
import automated.tests.data.TestSetData;
import automated.tests.helpers.AutomatedTestsHelper;
import automated.tests.helpers.base.BasicsHelper;
import automated.tests.helpers.common.CommonHelper;
import automated.tests.helpers.common.load.base.LoadFromFileBase;
import automated.tests.helpers.groovy.ExecuteGroovyCode;
import automated.tests.helpers.items.NameValue;
import automated.tests.helpers.reflexions.ReflexionsHelper;
import automated.tests.helpers.reflexions.data.ConstructorInfoData;
import automated.tests.helpers.reflexions.data.MethodInfoData;
import automated.tests.helpers.reflexions.data.ParameterInfoData;
import automated.tests.helpers.reflexions.data.TypeInfoData;
import automated.tests.helpers.reflexions.data.filters.ModifiersFilter;
import automated.tests.helpers.types.FilesCharsetsTypes;
import automated.tests.templates.AssertDoesNotThrowTemplate;
import automated.tests.templates.AssertTemplate;
import automated.tests.templates.AssertThrowsTemplate;
import automated.tests.templates.ConstructorTestSetTemplate;
import automated.tests.templates.CoverageOnlyTemplate;
import automated.tests.templates.MethodTestSetTemplate;
import automated.tests.templates.TestCaseTemplate;
import automated.tests.templates.TestClassTemplate;
import automated.tests.templates.TestTemplate;
import automated.tests.templates.TestsSuiteTemplate;
import automated.tests.types.AutomatedTestsAnnotationsTypes;
import groovy.lang.GroovyRuntimeException;
import groovy.util.ScriptException;
import junit.JunitHelper;

/**
 * Générateur des cas de tests automatisés
 * @author Claude Toupin - 25 déc. 2021
 */
@AddImportsForTesting(java.lang.reflect.Modifier.class)
@SkipImportsForTesting({ FilenameFilter.class, TypeInfoData.class })
@DefaultParameterTestValue(type = boolean.class, name = "autoUpdate", value = "true")
@DefaultParameterTestValue(type = boolean.class, name = "debug", value = "false")
public class AutomatedTestsUnitsGenerator extends ExecuteGroovyCode implements FilenameFilter, ModifiersFilter {
	/** Étiquette d'identification des fichiers produits par les tests automatisés **/
	final public static String AUTOMATED_TESTS_TAG = " * " + AutomatedTestsAnnotationsTypes.AUTOMATED_TESTS.toString() + " -> ";

	/** Étiquette d'identification des fichiers produits par les tests automatisés en français **/
	final public static String AUTOMATED_TESTS_TAG_FRA = AUTOMATED_TESTS_TAG + "Pour que ce fichier ne soit plus modifié par le générateur, il suffit de supprimer cette ligne de commentaire";

	/** Étiquette d'identification des fichiers produits par les tests automatisés en anglais **/
	final public static String AUTOMATED_TESTS_TAG_ENG = AUTOMATED_TESTS_TAG + "To prevent the generator from modifying this file, simply delete this comment line";

	/** Type de jeu de caractères par défaut pour les fichiers **/
	final public static FilesCharsetsTypes CHARSET_TYPE_DEF = BasicsHelper.areEquals(Charset.defaultCharset().name(), "UTF-8") ? FilesCharsetsTypes.UTF_8 : FilesCharsetsTypes.ISO_8859_1;

	/**
	 * Vérification pour déterminer si un fichier de tests a été produit par le générateur des unités de tests automatisés
	 * @author Claude Toupin - 28 déc. 2021
	 */
	protected class CheckAutomatedTestsFile extends LoadFromFileBase {
		/** Indicateur de fichier de tests produit par le générateur des unités de tests automatisés **/
		private boolean automatedTestsFile;

		/**
		 * Constructeur de base
		 * @param filename Nom du fichier
		 * @throws IOException en cs d'erreur...
		 */
		protected CheckAutomatedTestsFile(String filename) throws IOException {
			super(filename, CHARSET_TYPE_DEF);
			this.automatedTestsFile = false;
			process();
		}

		/**
		 * Constructeur de base
		 * @param file Fichier
		 * @throws IOException en cs d'erreur...
		 */
		protected CheckAutomatedTestsFile(File file) throws IOException {
			super(file, CHARSET_TYPE_DEF);
			this.automatedTestsFile = false;
			process();
		}

		/*
		 * (non-Javadoc)
		 * @see outils.commun.load.base.LoadFromFileBase#parseBuffer(java.io.BufferedReader)
		 */
		@Override
		protected void parseBuffer(BufferedReader bufferedReader) throws IOException {
			String line;

			while ((line = bufferedReader.readLine()) != null) {
				line = removeBomMarker(line);

				if (BasicsHelper.startsWith(line, AUTOMATED_TESTS_TAG)) {
					this.automatedTestsFile = true;
					break;
				}
			}
		}

		/**
		 * Extrait le champ automatedTestsFile
		 * @return un boolean
		 */
		public boolean isAutomatedTestsFile() {
			return automatedTestsFile;
		}

		/**
		 * Modifie le champ automatedTestsFile
		 * @param automatedTestsFile La valeur du champ automatedTestsFile
		 */
		public void setAutomatedTestsFile(boolean automatedTestsFile) {
			this.automatedTestsFile = automatedTestsFile;
		}
	}

	/** Nombre maximum de tests par tranche de tests **/
	final private int maxTests;

	/** Indicateur de textes en français **/
	final private boolean french;

	/** Nom du projet **/
	final private String project;

	/** Classe du générateur des tests automatisés **/
	final private String generatorClass;

	/** Répertoire de sortie **/
	final private String outputDir;

	/** Package de sortie **/
	final private String outputPackage;

	/** Liste des classes qui doivent toujours être référencées au long (i.e. package.class) afin d'éviter les confilts **/
	final private List<Class<?>> fullnameClassesRequiredList;

	/** Liste des packages requis **/
	final private List<String> requiredPackagesList;

	/** Liste des packages non requis **/
	final private List<String> notRequiredPackagesList;

	/** Code du test unitaire de la classe **/
	final private List<String> testClassCode;

	/** Appel au code du test unitaire de la classe **/
	final private List<String> testClassCall;

	/** Appel des tests de couverture en premier **/
	final private List<String> testClassBeforeAll;

	/** Appel des tests de couverture en dernier **/
	final private List<String> testClassAfterAll;

	/** Liste des classes des tests automatisés générés par programmation **/
	final private List<Class<?>> automatedTestsCasesClassesList;

	/** Modèle pour le test d'une affirmation **/
	final private transient AssertTemplate assertTemplate;

	/** Modèle pour le test sans exception générée **/
	final private transient AssertDoesNotThrowTemplate assertDoesNotThrowsTemplate;

	/** Modèle pour le test d'une exception **/
	final private transient AssertThrowsTemplate assertThrowsTemplate;

	/** Modèle pour le test de couverture seulement **/
	final private transient CoverageOnlyTemplate coverageOnlyTemplate;

	/** Modèle pour un jeu de test d'un constructeur **/
	final private transient ConstructorTestSetTemplate constructorTestSetTemplate;

	/** Modèle pour un jeu de test d'une méthode **/
	final private transient MethodTestSetTemplate methodTestSetTemplate;

	/** Modèle pour un nom de test de la classe du test unitaire **/
	final private transient TestTemplate testTemplate;

	/** Modèlepour les valeurs des tests automatisés par programmation de la classe du test unitaire **/
	final private transient TestCaseTemplate testCaseTemplate;

	/** Modèle pour une classe du test unitaire **/
	final private transient TestClassTemplate testClassTemplate;

	/** Modèle pour une classe d'une suite de tests **/
	final private transient TestsSuiteTemplate testsSuiteTemplate;

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	@TestMethodsInstance
	public AutomatedTestsUnitsGenerator(String project, Class<?> generatorClass, String outputDir, String outputPackage, boolean debug, boolean french) throws Exception {
		this(project, generatorClass.getName(), outputDir, outputPackage, null, true, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param fullnameClassesRequiredList Liste des classes qui doivent toujours être référencées au long (i.e. package.class) afin d'éviter les confilts
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, Class<?> generatorClass, String outputDir, String outputPackage, List<Class<?>> fullnameClassesRequiredList, boolean debug, boolean french) throws Exception {
		this(project, generatorClass.getName(), outputDir, outputPackage, fullnameClassesRequiredList, true, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Nom de la classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, String generatorClass, String outputDir, String outputPackage, boolean debug, boolean french) throws Exception {
		this(project, generatorClass, outputDir, outputPackage, null, true, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Nom de la classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param fullnameClassesRequiredList Liste des classes qui doivent toujours être référencées au long (i.e. package.class) afin d'éviter les confilts
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, String generatorClass, String outputDir, String outputPackage, List<Class<?>> fullnameClassesRequiredList, boolean debug, boolean french) throws Exception {
		this(project, generatorClass, outputDir, outputPackage, fullnameClassesRequiredList, true, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param autoUpdate Indicateur de mise à jour automatique des fichiers de tests du répertoire de sortie produits si le fichier source a été modifié
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, Class<?> generatorClass, String outputDir, String outputPackage, boolean autoUpdate, boolean debug, boolean french) throws Exception {
		this(project, generatorClass.getName(), outputDir, outputPackage, null, autoUpdate, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param fullnameClassesRequiredList Liste des classes qui doivent toujours être référencées au long (i.e. package.class) afin d'éviter les confilts
	 * @param autoUpdate Indicateur de mise à jour automatique des fichiers de tests du répertoire de sortie produits si le fichier source a été modifié
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, Class<?> generatorClass, String outputDir, String outputPackage, List<Class<?>> fullnameClassesRequiredList, boolean autoUpdate, boolean debug, boolean french) throws Exception {
		this(project, generatorClass.getName(), outputDir, outputPackage, fullnameClassesRequiredList, autoUpdate, debug, french);
	}

	/**
	 * Constructeur de base
	 * @param project Nom du projet
	 * @param generatorClass Nom de la classe du générateur des tests automatisés
	 * @param outputDir Répertoire de sortie
	 * @param outputPackage Package de sortie
	 * @param fullnameClassesRequiredList Liste des classes qui doivent toujours être référencées au long (i.e. package.class) afin d'éviter les confilts
	 * @param autoUpdate Indicateur de mise à jour automatique des fichiers de tests du répertoire de sortie produits si le fichier source a été modifié
	 * @param debug Indicateur de mode de débogage des tests en groovy (i.e. 1 test à la fois)
	 * @param french Indicateur de textes en français
	 * @throws Exception en cas d'erreur...
	 */
	public AutomatedTestsUnitsGenerator(String project, String generatorClass, String outputDir, String outputPackage, List<Class<?>> fullnameClassesRequiredList, boolean autoUpdate, boolean debug, boolean french) throws Exception {
		super();

		if (BasicsHelper.isEmpty(project)) {
			throw new Exception(french ? "Pas de nom de projet de spécifié" : "No project name specified");
		}

		if (BasicsHelper.isEmpty(generatorClass)) {
			throw new Exception(french ? "Pas de nom de la classe du générateur des tests automatisés de spécifié" : "No automated test generator class name specified");
		}

		if (BasicsHelper.isEmpty(outputDir)) {
			throw new Exception(french ? "Pas de répertoire de sortie de spécifié" : "No output directory specified");
		}

		if (BasicsHelper.isEmpty(outputPackage)) {
			throw new Exception(french ? "Pas de package de sortie de spécifié" : "No output package specified");
		}

		this.maxTests = debug ? 1 : 100;
		this.french = french;
		this.project = project;
		this.generatorClass = generatorClass;
		this.outputDir = outputDir;
		this.outputPackage = outputPackage;
		this.fullnameClassesRequiredList = new ArrayList<Class<?>>();
		this.requiredPackagesList = new ArrayList<String>();
		this.notRequiredPackagesList = new ArrayList<String>();
		this.testClassCode = new ArrayList<String>();
		this.testClassCall = new ArrayList<String>();
		this.testClassBeforeAll = new ArrayList<String>();
		this.testClassAfterAll = new ArrayList<String>();
		this.automatedTestsCasesClassesList = new ArrayList<Class<?>>();
		this.assertTemplate = new AssertTemplate();
		this.assertDoesNotThrowsTemplate = new AssertDoesNotThrowTemplate();
		this.assertThrowsTemplate = new AssertThrowsTemplate();
		this.coverageOnlyTemplate = new CoverageOnlyTemplate();
		this.constructorTestSetTemplate = new ConstructorTestSetTemplate();
		this.methodTestSetTemplate = new MethodTestSetTemplate();
		this.testTemplate = new TestTemplate(french);
		this.testCaseTemplate = new TestCaseTemplate(french);
		this.testClassTemplate = new TestClassTemplate(french);
		this.testsSuiteTemplate = new TestsSuiteTemplate(french);

		this.fullnameClassesRequiredList.add(java.sql.Date.class);
		this.fullnameClassesRequiredList.add(java.util.Date.class);

		if (!BasicsHelper.isEmpty(fullnameClassesRequiredList)) {
			for (Class<?> fullnameClasseRequired : fullnameClassesRequiredList) {
				if (!this.fullnameClassesRequiredList.contains(fullnameClasseRequired)) {
					this.fullnameClassesRequiredList.add(fullnameClasseRequired);
				}
			}
		}

		if (!autoUpdate) {
			cleanOutputDir();
		}
	}

	/**
	 * Affichage du code source
	 */
	protected void displaySource() {
		if (french) {
			CommonHelper.console("-------- Début du code source --------");
			CommonHelper.console(getSource());
			CommonHelper.console("-------- Fin du code source --------");
		} else {
			CommonHelper.console("-------- Start of source code --------");
			CommonHelper.console(getSource());
			CommonHelper.console("-------- End of source code --------");
		}
	}

	/*
	 * (non-Javadoc)
	 * @see outils.groovy.ExecuteGroovyCode#execute(java.util.List)
	 */
	@Override
	protected Object execute(List<String> source) throws Throwable {
		setSource(source);

		try {
			// displaySource();
			return super.execute();
		} catch (GroovyRuntimeException groovyRuntimeException) {
			displaySource();
			throw groovyRuntimeException;
		} catch (GroovyCastException groovyCastException) {
			displaySource();
			throw groovyCastException;
		} catch (ScriptException scriptException) {
			displaySource();
			throw scriptException;
		} catch (Throwable throwable) {
			throw throwable;
		}
	}

	/**
	 * Initialisation de la liste des packages requis
	 */
	protected void initRequiredPackagesList() {
		requiredPackagesList.clear();
		notRequiredPackagesList.clear();

		addImport("org.junit.jupiter.api.*");
		addImport(File.class);
		addImport(Files.class);
		addImport(Path.class);
		addImport(JunitHelper.class);
	}

	/*
	 * (non-Javadoc)
	 * @see outils.groovy.ExecuteGroovyCode#getRequiredPackagesList()
	 */
	@Override
	protected List<String> getRequiredPackagesList() {
		return requiredPackagesList;
	}

	/**
	 * Ajout l'importation d'une classe
	 * @param name Nom de la classe à importer
	 */
	protected void addImport(String name) {
		for (Class<?> classe : fullnameClassesRequiredList) {
			if (BasicsHelper.areEquals(classe.getName(), name)) {
				return;
			}
		}

		if (notRequiredPackagesList.contains(name)) {
			return;
		}

		String code = "import " + name.replace('$', '.') + ";";

		if (!requiredPackagesList.contains(code)) {
			requiredPackagesList.add(code);
		}
	}

	/**
	 * Ajout l'importation d'une classe
	 * @param sourceClass La classe à importer
	 */
	protected void addImport(Class<?> sourceClass) {
		addImport(sourceClass.getName());
	}

	/**
	 * Ajout l'importation des données d'un type de classe
	 * @param typeInfoData Les données d'un type de classe à importer
	 */
	protected void addImport(TypeInfoData typeInfoData) {
		if (typeInfoData.isImportRequired()) {
			for (String importName : typeInfoData.getImportRequiredAsStringList()) {
				addImport(importName);
			}
		}
	}

	/**
	 * Ajout l'importation d'une liste de paramètres
	 * @param parametersList Liste des paramètres à importer
	 */
	protected void addImport(List<ParameterInfoData> parametersList) {
		for (ParameterInfoData parameterInfoData : parametersList) {
			addImport(parameterInfoData);
		}
	}

	/**
	 * Ajout des cas de tests supplémentaires à être exécutés pour les tests de couverture
	 * @param signature Signature de la classe
	 * @param annotationValues Valeurs de l'annotation
	 * @throws Exception Exception en cas d'erreur...
	 */
	protected void addCoverageTestsCases(String signature, Class<?>[] annotationValues) throws Exception {
		if (BasicsHelper.isEmpty(annotationValues)) {
			String message = french ? //
					"Pas de données pour " + AutomatedTestsAnnotationsTypes.COVERAGE_TESTS_CASES + "() de " + signature //
					: "No data for " + AutomatedTestsAnnotationsTypes.COVERAGE_TESTS_CASES + "() of " + signature //
			;

			throw new Exception(message);
		}

		for (Class<?> coverageTestsCasesClass : annotationValues) {
			if (!ICoverageTestsCases.class.isAssignableFrom(coverageTestsCasesClass)) {
				String message = french ? //
						"La classe " + coverageTestsCasesClass.getName() + " de l'annotation " + AutomatedTestsAnnotationsTypes.COVERAGE_TESTS_CASES.toString() + " doit implémenter l'interface " + ICoverageTestsCases.class.getName() //
						: "The " + coverageTestsCasesClass.getName() + " class of the " + AutomatedTestsAnnotationsTypes.COVERAGE_TESTS_CASES.toString() + " annotation must implement the " + ICoverageTestsCases.class.getName() + " interface" //
				;

				throw new Exception(message);
			}

			String coverageClass = coverageTestsCasesClass.getName().replace('$', '.');

			String doBeforeAll = "\t\t((ICoverageTestsCases) " + coverageClass + ".class.getDeclaredConstructor().newInstance()).doBeforeAll();";
			String doAfterAll = "\t\t((ICoverageTestsCases) " + coverageClass + ".class.getDeclaredConstructor().newInstance()).doAfterAll();";

			if (!testClassBeforeAll.contains(doBeforeAll)) { // Non requis: && !testClassAfterAll.contains(doAfterAll)
				testClassBeforeAll.add(doBeforeAll);
				testClassAfterAll.add(doAfterAll);

				addImport(ICoverageTestsCases.class);
			} else {
				String message = french ? //
						"Doublon pour la classe des tests de couverture: " + coverageClass + " de " + signature //
						: "Duplicate for the coverage test class: " + coverageClass + " of " + signature //
				;

				throw new Exception(message);
			}
		}
	}

	/**
	 * Produit le code des fichiers temporaires pour une liste de paramètres donnée
	 * @param tempFileList La liste des paramètres à produire le code
	 * @return le code des fichiers temporaires pour une liste de paramètres donnée
	 */
	protected List<String> produceTempFilesTest(List<ParameterInfoData> tempFileList) {
		List<String> code = new ArrayList<String>();

		if (!BasicsHelper.isEmpty(tempFileList)) {
			int id = 1;

			for (ParameterInfoData parameter : tempFileList) {
				Class<?> classe = parameter.getClassData();

				if (File.class.equals(classe) || Path.class.equals(classe) || InputStream.class.equals(classe)) {
					String __file__ = "__file" + id + "__";

					code.add("java.io.File " + __file__ + " = java.io.File.createTempFile(\"" + AutomatedTestsUnitsGenerator.class.getSimpleName() + "\", \"" + CommonHelper.TEXT_EXTENSION + "\");");
					code.add(__file__ + ".deleteOnExit();");
					code.add("java.nio.file.Files.write(" + __file__ + ".toPath(), \"" + TestData.TEST_STRING + "\\r\\n\".getBytes());");

					if (Path.class.equals(classe)) {
						code.add("path = " + __file__ + ".toPath();");
					} else {
						code.add("file = " + __file__ + ";");
					}

					id++;
				}
			}
		}

		return code;
	}

	/**
	 * Produit le code de test d'un constructeur
	 * @param testname Nom du test
	 * @param constructorInfoData Les données du constructeur
	 * @param testData Les données de test
	 * @throws Exception en cas d'erreur...
	 */
	protected void produceConstructorTest(String testname, ConstructorInfoData constructorInfoData, TestData testData) throws Exception {
		List<String> code = new ArrayList<String>();

		addImport(testData.getTempFileList());

		if (testData.isAddTestEnumImport()) {
			addImport(JunitHelper.TestEnum.class);
		}

		if (!testData.getTestsCasesCodeList().isEmpty()) {
			code.addAll(testCaseTemplate.produceTest(testData.getTestsCasesCodeList()));
		}

		String constructorName = constructorInfoData.getConstructor().getName();
		String signature = constructorInfoData.getSignature();

		CommonHelper.console((french ? "Constructeur: " : "Constructor: ") + signature);

		boolean suppressWarnings = false;

		List<TestSetData> testsSetsList = testData.getTestsSetsList();

		if (testData.isCoverageOnly()) {
			for (TestSetData testSetData : testsSetsList) {
				testSetData.setJavaConstructor(testSetData.getConstructorName() + "(" + CommonHelper.toList(testSetData.getValuesList(), ", ") + ")");

				suppressWarnings |= testSetData.isSuppressWarnings();

				String test = "new " + testSetData.getJavaConstructor();

				String message = signature + " -> " + test;

				code.add(coverageOnlyTemplate.produceCoverageOnlyTest(test, message));
			}
		} else {
			List<String> errorMessagesList = new ArrayList<String>();

			for (int index = 0; index < testsSetsList.size(); index += maxTests) {
				List<String> source = new ArrayList<String>();
				source.addAll(requiredPackagesList);
				source.add(TestData.TEST_ENUM_INIT_CODE);
				source.add(TestData.CLEAN_UP_TEST_CODE);
				source.add(ConstructorTestSetTemplate.TESTS_RESULTS_INIT_CODE);

				for (int i = 0; i < maxTests; i++) {
					if ((index + i) >= testsSetsList.size()) {
						break;
					}

					TestSetData testSetData = testsSetsList.get(index + i);
					testSetData.setConstructorName(constructorInfoData.getTypeName(testData.getGenericTestTypesDict(), constructorInfoData.isArrayType() ? TestData.DEFAULT_ARRAY_GENERIC_TYPE : TestData.DEFAULT_GENERIC_TYPE));
					testSetData.setGroovyConstructor(testSetData.getConstructorName() + "(" + CommonHelper.toList(testSetData.getGroovyValuesList(), ", ") + ")");

					String test = "new " + testSetData.getGroovyConstructor();

					source.add(TestData.DO_CLEAN_UP_TEST_CODE);
					source.addAll(testSetData.getVariablesList());
					source.addAll(constructorTestSetTemplate.produceTest(produceTempFilesTest(testData.getTempFileList()), constructorName, test));
				}

				source.add(TestData.DO_CLEAN_UP_TEST_CODE);
				source.add(ConstructorTestSetTemplate.TESTS_RESULTS_RETURN_CODE);

				JunitHelper.cleanTestTempDir();

				List<?> testsResults = null;

				try {
					testsResults = (List<?>) execute(source);
				} catch (GroovyRuntimeException groovyRuntimeException) {
					throw new RuntimeException(signature + ": " + groovyRuntimeException.getMessage());
				} catch (GroovyCastException groovyCastException) {
					throw new RuntimeException(signature + ": " + groovyCastException.getMessage());
				} catch (ScriptException scriptException) {
					throw new Exception(signature + ": " + scriptException.getMessage());
				} catch (Throwable throwable) {
					throw new Exception(throwable);
				}

				for (int i = 0; i < maxTests; i++) {
					if ((index + i) >= testsSetsList.size()) {
						break;
					}

					TestSetData testSetData = testsSetsList.get(index + i);
					testSetData.setJavaConstructor(testSetData.getConstructorName() + "(" + CommonHelper.toList(testSetData.getValuesList(), ", ") + ")");

					suppressWarnings |= testSetData.isSuppressWarnings();

					String test = "new " + testSetData.getJavaConstructor();

					String message = signature + " -> " + test;

					Object result = testsResults.get(i);

					if (result instanceof Throwable) {
						testSetData.setThrowable((Throwable) result);

						boolean processed = false;

						if (!testData.isSkipAllExceptions() && !testData.getSkipExceptionsList().contains(result.getClass())) {
							for (TypeInfoData exception : testData.getExceptionsList()) {
								if (exception.isInstance(result)) {
									processed = true;
									code.addAll(assertThrowsTemplate.produceTest(testSetData.getThrowable(), test, message));
									break;
								}
							}

							// Ne pas considérer comme traité (i.e. processed = true)
							if (!processed && (result instanceof RuntimeException)) {
								code.addAll(assertThrowsTemplate.produceTest(testSetData.getThrowable(), test, message));
							}
						}

						if (!processed) {
							errorMessagesList.add(testSetData.getThrowable().getClass().getName() + ": " + testSetData.getThrowable().getMessage());
						}
					} else {
						code.add(assertTemplate.produceNotNullTest(test, message));
					}
				}
			}

			if (code.isEmpty()) {
				displaySource();

				if (!errorMessagesList.isEmpty()) {
					CommonHelper.console((french ? "Liste des messages pour " : "List of messages for ") + signature);
					CommonHelper.console("------------------------------");
					CommonHelper.console(errorMessagesList);
					CommonHelper.console("------------------------------");
				}

				throw new RuntimeException((french ? "Aucun test valide pour " : "No valid test for ") + signature);
			}
		}

		testClassCode.addAll(testTemplate.produceTest(signature, testname, suppressWarnings, code));
		testClassCall.add("\t\t" + testname + "();");

		if (!testData.getAutomatedTestsCasesClassesList().isEmpty()) {
			for (Class<?> automatedTestsCasesClass : testData.getAutomatedTestsCasesClassesList()) {
				if (!automatedTestsCasesClassesList.contains(automatedTestsCasesClass)) {
					automatedTestsCasesClassesList.add(automatedTestsCasesClass);
				}
			}
		}
	}

	/**
	 * Produit le code de test d'une méthode
	 * @param sourceClass La classe à générer le test unitaire
	 * @param constructorsTestUnitData Données de tests des constructeurs pour la méthode
	 * @param testname Nom du test
	 * @param methodInfoData Les données de la méthode
	 * @param testData Les données de test
	 * @throws Exception en cas d'erreur...
	 */
	protected void produceMethodTest(Class<?> sourceClass, ConstructorsTestUnitData constructorsTestUnitData, String testname, MethodInfoData methodInfoData, TestData testData) throws Exception {
		List<String> code = new ArrayList<String>();

		addImport(testData.getTempFileList());

		if (testData.isAddTestEnumImport()) {
			addImport(JunitHelper.TestEnum.class);
		}

		if (!testData.getTestsCasesCodeList().isEmpty()) {
			code.addAll(testCaseTemplate.produceTest(testData.getTestsCasesCodeList()));
		}

		String methodName = methodInfoData.getMethod().getName();
		String signature = methodInfoData.getSignature();

		CommonHelper.console((french ? "Méthode: " : "Method: ") + signature);

		boolean suppressWarnings = false;

		List<ParameterInfoData> constructorsTempDirList = new ArrayList<ParameterInfoData>();

		if (Modifier.isStatic(methodInfoData.getMethod().getModifiers())) {
			signature = "static " + signature;

			code.addAll(produceMethodTest(methodName, signature, sourceClass.getName(), methodInfoData.isVoid(), testData.isCoverageOnly(), testData.isSkipAllExceptions(), testData.getExceptionsList(), testData.getSkipExceptionsList(), testData.getTestsSetsList(), testData.getTempFileList()));
		} else if (sourceClass.isEnum()) {
			for (Enum<?> value : ReflexionsHelper.getEnumClassValuesList(sourceClass)) {
				code.addAll(produceMethodTest(methodName, signature, value.getClass().getName() + "." + value.name(), methodInfoData.isVoid(), testData.isCoverageOnly(), testData.isSkipAllExceptions(), testData.getExceptionsList(), testData.getSkipExceptionsList(), testData.getTestsSetsList(), testData.getTempFileList()));
			}
		} else {
			int id = 1;

			List<String> variablesList = new ArrayList<String>();

			boolean equalsMethod = false;

			if (BasicsHelper.areEquals("equals", methodInfoData.getName()) && (methodInfoData.getParametersList().size() == 1)) {
				equalsMethod = methodInfoData.getParametersList().get(0).isObjectType();
			}

			for (String testnameMethodesInstance : constructorsTestUnitData.getTestnamesMethodsInstancesList()) {
				TestData constructorTestData = constructorsTestUnitData.getTestsDict().get(testnameMethodesInstance);

				constructorsTempDirList.addAll(constructorTestData.getTempFileList());

				for (TestSetData constructorTestSetData : constructorTestData.getTestsSetsList()) {
					if (constructorTestSetData.hasThrowable()) {
						continue;
					}

					String construction = constructorTestSetData.getJavaConstructor();

					String instance = "new " + construction;

					suppressWarnings |= constructorTestSetData.isSuppressWarnings();

					code.add("\t\t// " + construction);

					List<TestSetData> testsSetsList = new ArrayList<TestSetData>();

					for (TestSetData testSetData : testData.getTestsSetsList()) {
						testSetData.setConstructors(constructorTestSetData);
						testsSetsList.add(testSetData);
						suppressWarnings |= testSetData.isSuppressWarnings();
					}

					if (equalsMethod) {
						// Test de l'instance
						testsSetsList.add(new TestSetData(constructorTestSetData, instance));
					}

					code.addAll(produceMethodTest(methodName, signature, null, methodInfoData.isVoid(), testData.isCoverageOnly(), testData.isSkipAllExceptions(), testData.getExceptionsList(), testData.getSkipExceptionsList(), testsSetsList, testData.getTempFileList(constructorTestData.getTempFileList())));

					if (equalsMethod) {
						// Tests identitaires
						testsSetsList.clear();

						String var = "var" + BasicsHelper.asString(id++);

						String variable = constructorTestSetData.getConstructorName() + " " + var + " = " + instance;

						code.add("\t\t" + variable + "; // " + (french ? "Tests identitaires" : "Identity Tests"));

						variablesList.add(variable);

						testsSetsList.add(new TestSetData(constructorTestSetData, variable, var));

						for (TestSetData constructorEqualsTestSetData : constructorTestData.getTestsSetsList()) {
							if (constructorEqualsTestSetData.hasThrowable()) {
								continue;
							}

							for (TestSetData testSetData : testData.getTestsSetsList()) {
								testSetData.setConstructors(constructorTestSetData);
								testsSetsList.add(testSetData);
								suppressWarnings |= testSetData.isSuppressWarnings();
							}

							construction = constructorEqualsTestSetData.getJavaConstructor();

							instance = "new " + construction;

							testsSetsList.add(new TestSetData(constructorTestSetData, instance));
						}

						code.addAll(produceMethodTest(methodName, signature, var, methodInfoData.isVoid(), testData.isCoverageOnly(), testData.isSkipAllExceptions(), testData.getExceptionsList(), testData.getSkipExceptionsList(), testsSetsList, testData.getTempFileList(constructorTestData.getTempFileList())));
					}
				}
			}
		}

		testClassCode.addAll(testTemplate.produceTest(signature, testname, suppressWarnings, code));
		testClassCall.add("\t\t" + testname + "();");

		if (!testData.getAutomatedTestsCasesClassesList().isEmpty()) {
			for (Class<?> automatedTestsCasesClass : testData.getAutomatedTestsCasesClassesList()) {
				if (!automatedTestsCasesClassesList.contains(automatedTestsCasesClass)) {
					automatedTestsCasesClassesList.add(automatedTestsCasesClass);
				}
			}
		}
	}

	/**
	 * Produit le code de test des tests d'une méthode
	 * @param methodName Nom de la méthode
	 * @param signature Signature de la méthode
	 * @param instance Instance de la classe de la méthode
	 * @param isVoid Indicateur de méthode sans valeur de retour (void)
	 * @param coverageOnly Indicateur de test de couverture seulement
	 * @param skipAllExceptions Indicateur d'ignorer toutes les exceptions dans les tests automatisés
	 * @param exceptionsList Liste des exceptions de la méthode
	 * @param skipExcetionsList Liste des exceptions à ignorer dans les tests automatisés
	 * @param testsSetsList Liste des valeurs de tests
	 * @param tempFileList Liste des paramètres utilisant le fichier temporaire
	 * @return le code de test des tests d'une méthode
	 * @throws Exception en cas d'erreur...
	 */
	protected List<String> produceMethodTest(String methodName, String signature, String instance, boolean isVoid, boolean coverageOnly, boolean skipAllExceptions, List<TypeInfoData> exceptionsList, List<Class<?>> skipExcetionsList, List<TestSetData> testsSetsList, List<ParameterInfoData> tempFileList) throws Exception {
		List<String> code = new ArrayList<String>();

		if (coverageOnly) {
			for (TestSetData testSetData : testsSetsList) {
				String javaInstance = !BasicsHelper.isEmpty(instance) ? instance : ("new " + testSetData.getJavaConstructor());

				String test = javaInstance + "." + methodName + "(" + CommonHelper.toList(testSetData.getValuesList(), ", ") + ")";

				String message = signature + " -> " + test;

				code.add(coverageOnlyTemplate.produceCoverageOnlyTest(test, message));
			}
		} else {
			List<String> errorMessagesList = new ArrayList<String>();

			List<String> variablesList = new ArrayList<String>();

			for (int index = 0; index < testsSetsList.size(); index += maxTests) {
				List<String> source = new ArrayList<String>();
				source.addAll(requiredPackagesList);
				source.add(TestData.TEST_ENUM_INIT_CODE);
				source.add(TestData.CLEAN_UP_TEST_CODE);
				source.add(MethodTestSetTemplate.TESTS_RESULTS_INIT_CODE);
				source.addAll(produceTempFilesTest(tempFileList));
				source.addAll(variablesList);

				for (int i = 0; i < maxTests; i++) {
					if ((index + i) >= testsSetsList.size()) {
						break;
					}

					TestSetData testSetData = testsSetsList.get(index + i);

					String groovyInstance = !BasicsHelper.isEmpty(instance) ? instance : ("new " + testSetData.getGroovyConstructor());

					String test = groovyInstance + "." + methodName + "(" + CommonHelper.toList(testSetData.getGroovyValuesList(), ", ") + ")";

					source.add(TestData.DO_CLEAN_UP_TEST_CODE);

					if (!testSetData.getVariablesList().isEmpty()) {
						variablesList.addAll(testSetData.getVariablesList());
						source.addAll(testSetData.getVariablesList());
					}

					if (isVoid) {
						source.addAll(methodTestSetTemplate.produceNoResultTest(test));
					} else {
						source.addAll(methodTestSetTemplate.produceValueResultTest(test));
					}
				}

				source.add(TestData.DO_CLEAN_UP_TEST_CODE);
				source.add(MethodTestSetTemplate.TESTS_RESULTS_RETURN_CODE);

				JunitHelper.cleanTestTempDir();

				List<?> testsResults = null;

				try {
					testsResults = (List<?>) execute(source);
				} catch (GroovyRuntimeException groovyRuntimeException) {
					throw new RuntimeException(signature + ": " + groovyRuntimeException.getMessage());
				} catch (GroovyCastException groovyCastException) {
					throw new RuntimeException(signature + ": " + groovyCastException.getMessage());
				} catch (ScriptException scriptException) {
					throw new Exception(signature + ": " + scriptException.getMessage());
				} catch (Throwable throwable) {
					throw new Exception(throwable);
				}

				for (int i = 0; i < maxTests; i++) {
					if ((index + i) >= testsSetsList.size()) {
						break;
					}

					TestSetData testSetData = testsSetsList.get(index + i);

					String javaInstance = !BasicsHelper.isEmpty(instance) ? instance : ("new " + testSetData.getJavaConstructor());

					String test = javaInstance + "." + methodName + "(" + CommonHelper.toList(testSetData.getValuesList(), ", ") + ")";

					String message = signature + " -> " + test;

					Object result = testsResults.get(i);

					if (result instanceof Throwable) {
						testSetData.setThrowable((Throwable) result);

						boolean processed = false;

						if (!skipAllExceptions && !skipExcetionsList.contains(result.getClass())) {
							for (TypeInfoData exception : exceptionsList) {
								if (exception.isInstance(result)) {
									processed = true;
									code.addAll(assertThrowsTemplate.produceTest(testSetData.getThrowable(), test, message));
									break;
								}
							}

							// Ne pas considérer comme traité (i.e. processed = true)
							if (!processed && (result instanceof RuntimeException)) {
								code.addAll(assertThrowsTemplate.produceTest(testSetData.getThrowable(), test, message));
							}
						}

						if (!processed) {
							errorMessagesList.add(testSetData.getThrowable().getClass().getName() + ": " + testSetData.getThrowable().getMessage());
						}
					} else if (isVoid) {
						code.addAll(assertDoesNotThrowsTemplate.produceTest(test, message));
					} else if (result == null) {
						code.add(assertTemplate.produceNullTest(test, message));
					} else {
						TypeInfoData resultInfoData = new TypeInfoData(result.getClass());

						if (resultInfoData.isArrayType()) {
							code.add(assertTemplate.produceNotNullTest(test, message));
						} else if (resultInfoData.hasPrimitiveAsClass()) {
							if (result instanceof Character) {
								char c = ((Character) result).charValue();

								if (Character.isISOControl(c)) {
									code.add(assertTemplate.produceEqualsTest("(char) " + BasicsHelper.intToString(c), test, message));
								} else if (c == '\'') {
									code.add(assertTemplate.produceEqualsTest("'\\''", test, message));
								} else if (c == '\\') {
									code.add(assertTemplate.produceEqualsTest("'\\\\'", test, message));
								} else {
									code.add(assertTemplate.produceEqualsTest("'" + c + "'", test, message));
								}
							} else if (result instanceof Integer) {
								Integer numerical = (Integer) result;

								String value = result.toString();

								if (Integer.MIN_VALUE == numerical.intValue()) {
									value = "Integer.MIN_VALUE";
								} else if (Integer.MAX_VALUE == numerical.intValue()) {
									value = "Integer.MAX_VALUE";
								} else {
									value = "(int) " + result.toString();
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else if (result instanceof Long) {
								Long numerical = (Long) result;

								String value = result.toString();

								if (Long.MIN_VALUE == numerical.longValue()) {
									value = "Long.MIN_VALUE";
								} else if (Long.MAX_VALUE == numerical.longValue()) {
									value = "Long.MAX_VALUE";
								} else {
									value = "(long) " + result.toString() + "L";
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else if (result instanceof Float) {
								Float numerical = (Float) result;

								String value = result.toString();

								if (Float.MIN_VALUE == numerical.floatValue()) {
									value = "Float.MIN_VALUE";
								} else if (Float.MAX_VALUE == numerical.floatValue()) {
									value = "Float.MAX_VALUE";
								} else {
									value = "(float) " + result.toString();
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else if (result instanceof Double) {
								Double numerical = (Double) result;

								String value = result.toString();

								if (Double.MIN_VALUE == numerical.doubleValue()) {
									value = "Double.MIN_VALUE";
								} else if (Double.MAX_VALUE == numerical.doubleValue()) {
									value = "Double.MAX_VALUE";
								} else {
									value = "(double) " + result.toString();
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else if (result instanceof Short) {
								Short numerical = (Short) result;

								String value = result.toString();

								if (Short.MIN_VALUE == numerical.shortValue()) {
									value = "Short.MIN_VALUE";
								} else if (Short.MAX_VALUE == numerical.shortValue()) {
									value = "Short.MAX_VALUE";
								} else {
									value = "(short) " + result.toString();
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else if (result instanceof Byte) {
								Byte numerical = (Byte) result;

								String value = result.toString();

								if (Byte.MIN_VALUE == numerical.byteValue()) {
									value = "Byte.MIN_VALUE";
								} else if (Byte.MAX_VALUE == numerical.byteValue()) {
									value = "Byte.MAX_VALUE";
								} else {
									value = "(byte) " + result.toString();
								}

								code.add(assertTemplate.produceEqualsTest(value, test, message));
							} else {
								code.add(assertTemplate.produceEqualsTest(result.toString(), test, message));
							}
						} else if (result instanceof String) {
							code.add(assertTemplate.produceEqualsTest(CommonHelper.asJavaString(result.toString()), test, message));
						} else if (resultInfoData.isEnumType()) {
							code.add(assertTemplate.produceEqualsTest(resultInfoData.getTypeName() + "." + ((Enum<?>) result).name(), test, message));
						} else {
							code.add(assertTemplate.produceNotNullTest(test, message));
						}
					}
				}
			}

			if (code.isEmpty()) {
				displaySource();

				if (!errorMessagesList.isEmpty()) {
					CommonHelper.console((french ? "Liste des messages pour " : "List of messages for ") + signature);
					CommonHelper.console("------------------------------");
					CommonHelper.console(errorMessagesList);
					CommonHelper.console("------------------------------");
				}

				throw new RuntimeException((french ? "Aucun test valide pour " : "No valid test for ") + signature);
			}
		}

		return code;
	}

	/**
	 * Produit le code des assertions pour @BeforeAll des tests automatisés générés par programmation
	 * @param sourceClass La classe à générer le code des assertions pour @BeforeAll des tests automatisés générés par programmation
	 * @return le code des assertions pour @BeforeAll des tests automatisés générés par programmation
	 * @throws Exception en cas d'erreur...
	 */
	protected List<String> produceAssertBeforeAllCode(Class<?> sourceClass) throws Exception {
		List<String> assertBeforeAllCode = new ArrayList<String>();

		for (Class<?> automatedTestsCasesClass : automatedTestsCasesClassesList) {
			IAutomatedTestsCases automatedTestsCases = (IAutomatedTestsCases) automatedTestsCasesClass.getDeclaredConstructor().newInstance();

			// Pour obtenir 100% de couverture pour les tests automatisés par programmation
			ElementType[] elementsTypeList = new ElementType[] { ElementType.CONSTRUCTOR, ElementType.METHOD };

			Class<?>[] testClassesList = new Class<?>[] { null, sourceClass };

			String[] elementSignaturesList = new String[] { null, "" };

			for (ElementType elementType : elementsTypeList) {
				for (Class<?> testClass : testClassesList) {
					for (String elementSignature : elementSignaturesList) {
						String message = "beforeAll" + TestClassTemplate.getClassname(sourceClass.getSimpleName()) + "() -> " + AutomatedTestsAnnotationsTypes.AUTOMATED_TESTS_CASES + "(" + automatedTestsCasesClass.getName() + ".class)";

						List<AutomatedTestsCaseData> automatedTestsCaseDataList = null;

						try {
							switch (elementType) {
								case CONSTRUCTOR:
									automatedTestsCaseDataList = automatedTestsCases.getConstructorValues(testClass, elementSignature);
									break;
								case METHOD:
									automatedTestsCaseDataList = automatedTestsCases.getMethodValues(testClass, elementSignature);
									break;
								default:
									throw new RuntimeException((french ? "Pas de traitement pour " : "No case statement for ") + elementType);
							}

							if (!BasicsHelper.isEmpty(automatedTestsCaseDataList)) {
								assertBeforeAllCode.add(AutomatedTestsHelper.getTestCaseCode(automatedTestsCasesClass, testClass, elementType, elementSignature, message));
							}
						} catch (Throwable throwable) {
							assertBeforeAllCode.addAll(assertThrowsTemplate.produceTest(throwable, AutomatedTestsHelper.getTestCaseCondition(automatedTestsCasesClass, testClass, elementType, elementSignature), message));
						}
					}
				}
			}
		}

		return assertBeforeAllCode;
	}

	/**
	 * Produit les classes de la suite des tests unitaires
	 * @return la liste des noms des packages de la suite des tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	protected List<String> produceTestsSuites() throws Exception {
		return produceTestsSuites(outputPackage.replace(".", File.separator));
	}

	/**
	 * Produit les classes de la suite des tests unitaires
	 * @param baseDir Répertoire de base
	 * @return la liste des noms des packages de la suite des tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	protected List<String> produceTestsSuites(String baseDir) throws Exception {
		List<String> selectedPackagesList = new ArrayList<String>();

		String currentDir = CommonHelper.getFullname(outputDir, baseDir);

		List<NameValue> list = CommonHelper.scanForDirectories(currentDir, false);

		for (NameValue item : list) {
			selectedPackagesList.addAll(produceTestsSuites(CommonHelper.getFullname(baseDir, item.getValue())));
		}

		String packageName = BasicsHelper.replace(baseDir, File.separator, ".");

		if (!BasicsHelper.isEmpty(packageName)) {
			selectedPackagesList.add(packageName);
		}

		if (!selectedPackagesList.isEmpty()) {
			String name = !BasicsHelper.isEmpty(baseDir) ? new File(baseDir).getName() : CommonHelper.doJavaClassname(false, project);

			if (CommonHelper.scanForFiles(currentDir, false).isEmpty()) {
				String classname = TestClassTemplate.getClassname(packageName, name);

				CommonHelper.console((french ? "Traitement de la classe de tests unitaires " : "Unit test class processing ") + classname);

				produceTestsSuites(classname, packageName, name);
			}

			String classname = TestsSuiteTemplate.getClassname(packageName, name);

			String testsSuiteFilename = CommonHelper.getFullname(baseDir, TestsSuiteTemplate.getFilename(name));

			File testsSuitefile = new File(CommonHelper.getFullname(outputDir, testsSuiteFilename));

			CommonHelper.console((french ? "Traitement de la classe de la suite de tests unitaires " : "Unit test suite class processing ") + classname);

			CommonHelper.saveListToFile(testsSuiteTemplate.produceTestsSuite(project, generatorClass, classname, packageName, name, selectedPackagesList), testsSuitefile, CHARSET_TYPE_DEF);
		}

		return selectedPackagesList;
	}

	/**
	 * Produit la classe de la suite des tests unitaires
	 * @param displayName Nom de test à afficher
	 * @param packageName Nom du package de test
	 * @param name Nom du test
	 * @throws Exception en cas d'erreur...
	 */
	protected void produceTestsSuites(String displayName, String packageName, String name) throws Exception {
		String ouputPackageDir = packageName.replace(".", File.separator);

		initRequiredPackagesList();

		testClassCode.clear();
		testClassCall.clear();
		testClassBeforeAll.clear();
		testClassAfterAll.clear();

		testClassCode.add("");
		testClassCode.add("\t// " + (french ? "Aucune méthode de test" : "No test method"));

		testClassCall.add(assertTemplate.produceEqualsTest("true", "true", french ? "Test pour obtenir 100% de couverture" : "Test for 100% coverage"));

		String testClassFile = CommonHelper.getFullname(outputDir, ouputPackageDir, TestClassTemplate.getFilename(name));

		CommonHelper.saveListToFile(testClassTemplate.produceTest(project, generatorClass, displayName, packageName, name, requiredPackagesList, testClassBeforeAll, new ArrayList<String>(), testClassCall, testClassCode, testClassAfterAll), testClassFile, CHARSET_TYPE_DEF);
	}

	/**
	 * Extrait le message d'utilisation mutuellement exclusive pour 2 annotations données
	 * @param annotation1 La première annotation du message
	 * @param annotation2 La deuxième annotation du message
	 * @return le message d'utilisation mutuellement exclusive pour 2 annotations données
	 */
	protected String getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes annotation1, AutomatedTestsAnnotationsTypes annotation2) {
		return french ? //
				"L'utilisation de l'annotation " + annotation1 + " est mutuellement exclusive avec l'annotation " + annotation2 //
				: "The use of " + annotation1 + " annotation is mutually exclusive with " + annotation2 + " annotation" //
		;
	}

	/**
	 * Suppression des fichiers de tests du répertoire de sortie qui ont été produits par le générateur des unités de tests automatisés
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void cleanOutputDir() throws Exception {
		File dir = new File(outputDir);

		if (!dir.exists()) {
			CommonHelper.buildDirectory(outputDir);
		} else if (dir.isFile()) {
			String message = french ? "Le répertoire " + dir.getCanonicalPath() + " est un fichier !!!" //
					: "The directory " + dir.getCanonicalPath() + " is a file !!!" //
			;

			throw new Exception(message);
		} else {
			List<NameValue> list = CommonHelper.scanForFiles(dir, this, true);

			for (NameValue item : list) {
				String filename = CommonHelper.getFullname(outputDir, item.getName(), item.getValue());

				if (new CheckAutomatedTestsFile(filename).isAutomatedTestsFile()) {
					CommonHelper.deleteFileDirectory(filename);
				}
			}

			list = CommonHelper.scanForDirectories(dir, true, true);

			for (NameValue item : list) {
				String dirname = CommonHelper.getFullname(outputDir, item.getName(), item.getValue());

				CommonHelper.deleteEmptyDirectory(dirname);
			}

			CommonHelper.deleteEmptyDirectory(dir);
		}
	}

	/**
	 * Génération des tests unitaires pour un projet donné
	 * @param projectSourcesList Liste des répertoires du projet à générer les tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void generateProjectTestsUnits(String... projectSourcesList) throws Exception {
		generateProjectTestsUnits(this, BasicsHelper.asList(projectSourcesList));
	}

	/**
	 * Génération des tests unitaires pour un projet donnée
	 * @param filter Le filtre des noms de fichiers des classes java
	 * @param projectSourcesList Liste des répertoires du projet à générer les tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void generateProjectTestsUnits(FilenameFilter filter, String... projectSourcesList) throws Exception {
		generateProjectTestsUnits(this, BasicsHelper.asList(projectSourcesList));
	}

	/**
	 * Génération des tests unitaires pour un projet donné
	 * @param projectSourcesList Liste des répertoires du projet à générer les tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void generateProjectTestsUnits(List<String> projectSourcesList) throws Exception {
		generateProjectTestsUnits(this, projectSourcesList);
	}

	/**
	 * Génération des tests unitaires pour un projet donnée
	 * @param filter Le filtre des noms de fichiers des classes java
	 * @param projectSourcesList Liste des répertoires du projet à générer les tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void generateProjectTestsUnits(FilenameFilter filter, List<String> projectSourcesList) throws Exception {
		long start = System.currentTimeMillis();

		CommonHelper.console((french ? "Début de la génération des tests unitaires pour " : "Start of unit test generation for ") + project);

		AutomatedTestsStatisticsData projectStatisticsData = new AutomatedTestsStatisticsData();

		for (String projetSource : projectSourcesList) {
			List<NameValue> list = CommonHelper.scanForFiles(projetSource, filter, true);

			AutomatedTestsStatisticsData automatedTestsStatisticsData = new AutomatedTestsStatisticsData();

			String destination = new File(projetSource).getName();

			for (NameValue item : list) {
				String classname = CommonHelper.getFullname(item.getName(), item.getValue().substring(0, item.getValue().length() - CommonHelper.JAVA_EXTENSION.length())).replace(File.separator, ".");

				TypeInfoData sourceClass = new TypeInfoData(classname);

				boolean skipTesting = AutomatedTestsAnnotationsTypes.hasAnnotationType(sourceClass.getClassData(false).getAnnotations(), AutomatedTestsAnnotationsTypes.SKIP_TESTING);

				AutomatedTestsStatisticsData testUnitStatisticsData;

				if (skipTesting) {
					String message = french ? //
							"Pas de traitement de la classe " + sourceClass.getClassName(false) + " requis" //
							: "No processing of class " + sourceClass.getClassName(false) + " required" //
					;

					CommonHelper.console(message + " (i.e. " + AutomatedTestsAnnotationsTypes.SKIP_TESTING + ")");
					testUnitStatisticsData = new AutomatedTestsStatisticsData();
				} else {
					File file = new File(CommonHelper.getFullname(projetSource, item.getName(), item.getValue()));

					long lastModified = file.exists() ? file.lastModified() : 0L;

					testUnitStatisticsData = generateTestUnit(destination, sourceClass, lastModified);
				}

				automatedTestsStatisticsData.add(testUnitStatisticsData);
			}

			projectStatisticsData.add(automatedTestsStatisticsData);

			CommonHelper.console(automatedTestsStatisticsData.getSummary(french, true));
			CommonHelper.console("----------------------------------------------------------------------------");
		}

		generateTestsSuites();

		String message;

		if (french) {
			message = "Temps total de la génération des tests unitaires: " + BasicsHelper.topChrono(start, "jour", "heure", "minute", "seconde", "milliseconde", true);
		} else {
			message = "Total runtime of unit test generation: " + BasicsHelper.topChrono(start, "day", "hour", "minute", "second", "millisecond", true);
		}

		CommonHelper.console("----------------------------------------------------------------------------");
		CommonHelper.console(message);
		CommonHelper.console("----------------------------------------------------------------------------");
		CommonHelper.console(projectStatisticsData.getSummary(french, true));
		CommonHelper.console("----------------------------------------------------------------------------");
		CommonHelper.console((french ? "Fin de la génération des tests unitaires pour " : "End of unit test generation for ") + project);

		JunitHelper.cleanTestTempDir();
	}

	/**
	 * Génération du test unitaire pour une classe donnée
	 * @param destination Le répertoire de sortie de la classe à générer le test unitaire
	 * @param sourceClass La classe à générer le test unitaire
	 * @param lastModified Estampille de modification du fichier source de la classe à générer le test unitaire
	 * @return les données des statistiques de la génération du test unitaire pour la classe donnée
	 * @throws Exception en cas d'erreur
	 */
	@SkipTesting
	public AutomatedTestsStatisticsData generateTestUnit(String destination, TypeInfoData sourceClass, long lastModified) throws Exception {
		if (sourceClass == null) {
			throw new Exception(french ? "Pas de classe de spécifiée" : "No class specified");
		}

		testClassCode.clear();
		testClassCall.clear();
		testClassBeforeAll.clear();
		testClassAfterAll.clear();

		initRequiredPackagesList();

		String packageName = outputPackage + "." + destination + (!BasicsHelper.isEmpty(sourceClass.getPackageName()) ? ("." + sourceClass.getPackageName()) : "");

		String packageDir = BasicsHelper.replace(packageName, ".", File.separator);

		String testClassFilename = CommonHelper.getFullname(packageDir, TestClassTemplate.getFilename(sourceClass.getClassName()));

		File testClassFile = new File(CommonHelper.getFullname(outputDir, testClassFilename));

		if (testClassFile.exists()) {
			if (!new CheckAutomatedTestsFile(testClassFile).isAutomatedTestsFile()) {
				String message = french ? //
						"Pas de traitement de la classe " + sourceClass.getClassName(false) + " car le fichier des tests unitaires " + testClassFilename + " existe déjà et est un fichier permanent à ne pas être modifié par le générateur" //
						: "No processing of the class " + sourceClass.getClassName(false) + " because the unit test file " + testClassFilename + " already exists and is a permanent file not to be modified by the generator" //
				;

				CommonHelper.console(message);

				return new AutomatedTestsStatisticsData(1);
			} else if (testClassFile.lastModified() >= lastModified) {
				String message = french ? //
						"Pas de traitement de la classe " + sourceClass.getClassName(false) + " requis" //
						: "No processing required for the classe " + sourceClass.getClassName(false) //
				;

				CommonHelper.console(message);

				return new AutomatedTestsStatisticsData(1);
			}
		}

		AutomatedTestsStatisticsData automatedTestsStatisticsData = new AutomatedTestsStatisticsData();

		if (!sourceClass.isInterfaceType()) {
			if (accept(sourceClass.getClassData(false).getModifiers())) {
				long start = System.currentTimeMillis();

				CommonHelper.console((french ? "Traitement de la classe " : "Processing of the class ") + sourceClass.getClassName(false));

				boolean noParentMethodsTesting = false;

				boolean allowRuntimeExceptions = false;

				boolean skipAllExceptions = false;

				boolean coverageOnly = false;

				List<Class<?>> skipExcetionsList = new ArrayList<Class<?>>();

				Map<String, TestInfoValueData> defaultTestsValuesDict = new HashMap<String, TestInfoValueData>();

				Map<String, TestInfoValueData> defaultParametersTestsValuesDict = new HashMap<String, TestInfoValueData>();

				Map<String, TypeInfoData> genericTestTypesDict = new HashMap<String, TypeInfoData>();

				for (Annotation annotation : sourceClass.getClassData(false).getAnnotations()) {
					AutomatedTestsAnnotationsTypes type = AutomatedTestsAnnotationsTypes.getAutomatedTestsAnnotationType(annotation.annotationType());

					if (type != null) {
						switch (type) {
							case ADD_IMPORTS_FOR_TESTING:
								AddImportsForTesting addImportForTesting = (AddImportsForTesting) annotation;

								for (Class<?> classe : addImportForTesting.value()) {
									addImport(classe);
								}
								break;
							case ADD_IMPORTS_FOR_TESTING_LIST:
								AddImportsForTesting.List addImportForTestingList = (AddImportsForTesting.List) annotation;

								for (AddImportsForTesting item : addImportForTestingList.value()) {
									for (Class<?> classe : item.value()) {
										addImport(classe);
									}
								}
								break;
							case SKIP_IMPORTS_FOR_TESTING:
								SkipImportsForTesting skipImportsForTesting = (SkipImportsForTesting) annotation;

								for (Class<?> classe : skipImportsForTesting.value()) {
									notRequiredPackagesList.add(classe.getSimpleName());
									notRequiredPackagesList.add(classe.getName());
								}
								break;
							case SKIP_IMPORTS_FOR_TESTING_LIST:
								SkipImportsForTesting.List skipImportsForTestingList = (SkipImportsForTesting.List) annotation;

								for (SkipImportsForTesting item : skipImportsForTestingList.value()) {
									for (Class<?> classe : item.value()) {
										notRequiredPackagesList.add(classe.getSimpleName());
										notRequiredPackagesList.add(classe.getName());
									}
								}
								break;
							case DEFAULT_PARAMETER_TEST_VALUE:
								DefaultParameterTestValue defaultParameterTestValue = (DefaultParameterTestValue) annotation;

								String typename = defaultParameterTestValue.typename();

								if (BasicsHelper.isEmpty(typename)) {
									typename = new TypeInfoData(defaultParameterTestValue.type()).getTypeName();
								}

								if (BasicsHelper.isEmpty(defaultParameterTestValue.name())) {
									throw new Exception((french ? "Pas de nom de paramètre pour " : "No parameter name for ") + AutomatedTestsAnnotationsTypes.DEFAULT_PARAMETER_TEST_VALUE + "(type = " + defaultParameterTestValue.type().getName() + ", name = " + defaultParameterTestValue.name() + ", value = \"" + defaultParameterTestValue.value() + "\")");
								}

								String param = typename + " " + defaultParameterTestValue.name();

								defaultParametersTestsValuesDict.put(param, new TestInfoValueData(defaultParameterTestValue.value(), defaultParameterTestValue.type(), defaultParameterTestValue.filename(), defaultParameterTestValue.process(), defaultParameterTestValue.separator(), defaultParameterTestValue.strict()));
								break;
							case DEFAULT_PARAMETER_TEST_VALUE_LIST:
								DefaultParameterTestValue.List defaultParameterTestValueList = (DefaultParameterTestValue.List) annotation;

								for (DefaultParameterTestValue item : defaultParameterTestValueList.value()) {
									String itemTypename = item.typename();

									if (BasicsHelper.isEmpty(itemTypename)) {
										itemTypename = new TypeInfoData(item.type()).getTypeName();
									}

									if (BasicsHelper.isEmpty(item.name())) {
										throw new Exception((french ? "Pas de nom de paramètre pour " : "No parameter name for ") + AutomatedTestsAnnotationsTypes.DEFAULT_PARAMETER_TEST_VALUE + "(type = " + itemTypename + ", name = " + item.name() + ", value = \"" + item.value() + "\")");
									}

									String itemParam = itemTypename + " " + item.name();

									if (defaultParametersTestsValuesDict.containsKey(itemParam)) {
										String value = defaultParametersTestsValuesDict.get(itemParam).getValue();

										throw new Exception((french ? "Doublon de type de classe pour " : "Class type duplicate for ") + AutomatedTestsAnnotationsTypes.DEFAULT_PARAMETER_TEST_VALUE + "(type = " + itemTypename + ", name = " + item.name() + ", value = \"" + item.value() + "\") et " + AutomatedTestsAnnotationsTypes.DEFAULT_PARAMETER_TEST_VALUE + "(type = " + itemTypename + ", name = " + item.name() + ", value = \"" + value + "\")");
									}

									defaultParametersTestsValuesDict.put(itemParam, new TestInfoValueData(item.value(), item.type(), item.filename(), item.process(), item.separator(), item.strict()));
								}
								break;
							case DEFAULT_TEST_FILENAME:
								DefaultTestFilename defaultTestFilename = (DefaultTestFilename) annotation;

								if (BasicsHelper.isEmpty(defaultTestFilename.value())) {
									throw new Exception((french ? "Pas de nom de fichier par défaut pour " : "No default filename for ") + AutomatedTestsAnnotationsTypes.DEFAULT_TEST_FILENAME);
								}

								defaultTestsValuesDict.put(File.class.getName(), new TestInfoValueData(defaultTestFilename.value(), File.class, true, defaultTestFilename.process(), AutomatedTestsCaseData.SEPARATOR_CHAR_DEFAULT, true));
								defaultTestsValuesDict.put(Path.class.getName(), new TestInfoValueData(defaultTestFilename.value(), Path.class, true, defaultTestFilename.process(), AutomatedTestsCaseData.SEPARATOR_CHAR_DEFAULT, true));
								defaultTestsValuesDict.put(InputStream.class.getName(), new TestInfoValueData(defaultTestFilename.value(), InputStream.class, true, defaultTestFilename.process(), AutomatedTestsCaseData.SEPARATOR_CHAR_DEFAULT, true));
								break;
							case DEFAULT_TEST_VALUE:
								DefaultTestValue defaultTestValue = (DefaultTestValue) annotation;
								defaultTestsValuesDict.put(new TypeInfoData(defaultTestValue.type()).getTypeName(), new TestInfoValueData(defaultTestValue.value(), defaultTestValue.type(), defaultTestValue.filename(), defaultTestValue.process(), defaultTestValue.separator(), defaultTestValue.strict()));
								break;
							case DEFAULT_TEST_VALUE_LIST:
								DefaultTestValue.List defaultTestValueList = (DefaultTestValue.List) annotation;

								for (DefaultTestValue item : defaultTestValueList.value()) {
									String itemTypename = new TypeInfoData(item.type()).getTypeName();

									if (defaultTestsValuesDict.containsKey(itemTypename)) {
										String value = defaultTestsValuesDict.get(itemTypename).getValue();

										throw new Exception((french ? "Doublon de type de classe pour " : "Class type duplicate for ") + AutomatedTestsAnnotationsTypes.DEFAULT_TEST_VALUE + "(type = " + itemTypename + ", value = \"" + item.value() + "\") et " + AutomatedTestsAnnotationsTypes.DEFAULT_TEST_VALUE + "(type = " + itemTypename + ", value = \"" + value + "\")");
									}

									defaultTestsValuesDict.put(itemTypename, new TestInfoValueData(item.value(), item.type(), item.filename(), item.process(), item.separator(), item.strict()));
								}
								break;
							case GENERIC_TEST_TYPE:
								GenericTestType genericTestType = (GenericTestType) annotation;
								genericTestTypesDict.put(genericTestType.name(), new TypeInfoData(genericTestType.type()));
								break;
							case GENERIC_TEST_TYPE_LIST:
								GenericTestType.List genericTestTypesList = (GenericTestType.List) annotation;

								for (GenericTestType item : genericTestTypesList.value()) {
									if (genericTestTypesDict.containsKey(item.name())) {
										String value = genericTestTypesDict.get(item.name()).getTypeName();

										throw new Exception((french ? "Doublon de type générique pour " : "Generic type duplicate for ") + AutomatedTestsAnnotationsTypes.GENERIC_TEST_TYPE + "(name = \"" + item.name() + "\", type = " + item.type().getName() + ") et " + AutomatedTestsAnnotationsTypes.GENERIC_TEST_TYPE + "(name = \"" + item.name() + "\", type = " + value + ")");
									}

									genericTestTypesDict.put(item.name(), new TypeInfoData(item.type()));
								}
								break;
							case NO_PARENT_METHODS_TESTING:
								noParentMethodsTesting = true;
								break;
							case COVERAGE_TESTS_CASES:
								addCoverageTestsCases(sourceClass.getClassName(false), ((CoverageTestsCases) annotation).value());
								break;
							case COVERAGE_TESTS_CASES_LIST:
								CoverageTestsCases.List coverageTestsCasesList = (CoverageTestsCases.List) annotation;

								for (CoverageTestsCases item : coverageTestsCasesList.value()) {
									addCoverageTestsCases(sourceClass.getClassName(false), item.value());
								}

								break;
							case ALLOW_RUNTIME_EXCEPTIONS:
								if (skipAllExceptions) {
									throw new Exception(getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes.ALLOW_RUNTIME_EXCEPTIONS, AutomatedTestsAnnotationsTypes.SKIP_ALL_EXCEPTIONS));
								}

								allowRuntimeExceptions = true;
								break;
							case SKIP_ALL_EXCEPTIONS:
								if (allowRuntimeExceptions) {
									throw new Exception(getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes.SKIP_ALL_EXCEPTIONS, AutomatedTestsAnnotationsTypes.ALLOW_RUNTIME_EXCEPTIONS));
								}

								if (!skipExcetionsList.isEmpty()) {
									throw new Exception(getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes.SKIP_ALL_EXCEPTIONS, AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS));
								}

								skipAllExceptions = true;
								break;
							case SKIP_EXCEPTIONS:
								if (skipAllExceptions) {
									throw new Exception(getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS, AutomatedTestsAnnotationsTypes.SKIP_ALL_EXCEPTIONS));
								}

								SkipExceptions skipExceptions = (SkipExceptions) annotation;

								if (Throwable.class.isAssignableFrom(skipExceptions.value())) {
									skipExcetionsList.add(skipExceptions.value());
								} else {
									throw new Exception(AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS + "(" + skipExceptions.value().getTypeName() + ") " + (french ? "doit être un descendant de Throwable" : "must extend the Throwable class"));
								}

								break;
							case SKIP_EXCEPTIONS_LIST:
								if (skipAllExceptions) {
									throw new Exception(getMutuallyExclusiveMessage(AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS, AutomatedTestsAnnotationsTypes.SKIP_ALL_EXCEPTIONS));
								}

								SkipExceptions.List skipExceptionsItems = (SkipExceptions.List) annotation;

								for (SkipExceptions item : skipExceptionsItems.value()) {
									if (skipExcetionsList.contains(item.value())) {
										throw new Exception((french ? "Doublon d'exception pour " : "Duplicate exception for ") + AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS + "(" + item.value().getTypeName() + ")");
									}

									if (Throwable.class.isAssignableFrom(item.value())) {
										skipExcetionsList.add(item.value());
									} else {
										throw new Exception(AutomatedTestsAnnotationsTypes.SKIP_EXCEPTIONS + "(" + item.value().getTypeName() + ") " + (french ? "doit être un descendant de Throwable" : "must extend the Throwable class"));
									}
								}
								break;
							default:
								// Ignore...
						}
					}
				}

				ConstructorsTestUnitData constructorsTestUnitData = new ConstructorsTestUnitData(sourceClass.getClassData(false), coverageOnly, allowRuntimeExceptions, skipAllExceptions, french, project, outputDir, fullnameClassesRequiredList, skipExcetionsList, defaultParametersTestsValuesDict, defaultTestsValuesDict, genericTestTypesDict);

				for (ConstructorInfoData constructorInfoData : constructorsTestUnitData.getConstructorsList()) {
					addImport(constructorInfoData.getParametersList());
				}

				for (String testname : constructorsTestUnitData.getTestnamesList()) {
					produceConstructorTest(testname, constructorsTestUnitData.getConstructorsDict().get(testname), constructorsTestUnitData.getTestsDict().get(testname));
				}

				MethodsTestUnitData methodsTestUnitData = new MethodsTestUnitData(sourceClass.getClassData(false), noParentMethodsTesting, coverageOnly, allowRuntimeExceptions, skipAllExceptions, french, project, outputDir, fullnameClassesRequiredList, skipExcetionsList, defaultParametersTestsValuesDict, defaultTestsValuesDict, genericTestTypesDict);

				for (MethodInfoData methodInfoData : methodsTestUnitData.getMethodsList()) {
					addImport(methodInfoData.getParametersList());
				}

				for (String testname : methodsTestUnitData.getTestnamesList()) {
					produceMethodTest(sourceClass.getClassData(false), constructorsTestUnitData, testname, methodsTestUnitData.getMethodsDict().get(testname), methodsTestUnitData.getTestsDict().get(testname));
				}

				Collections.sort(requiredPackagesList);

				CommonHelper.buildDirectory(testClassFile.getParent());

				CommonHelper.saveListToFile(testClassTemplate.produceTest(project, generatorClass, sourceClass.getClassName(false), packageName, sourceClass.getClassName(), requiredPackagesList, testClassBeforeAll, produceAssertBeforeAllCode(sourceClass.getClassData(false)), testClassCall, testClassCode, testClassAfterAll), testClassFile, CHARSET_TYPE_DEF);

				automatedTestsStatisticsData = new AutomatedTestsStatisticsData(constructorsTestUnitData.getTestnamesList().size(), methodsTestUnitData.getTestnamesList().size());

				CommonHelper.console(automatedTestsStatisticsData.getSummary(french));

				String message;

				if (french) {
					message = "Temps de la génération des tests unitaires de la classe: " + BasicsHelper.topChrono(start, "jour", "heure", "minute", "seconde", "milliseconde", true);
				} else {
					message = "Time for generating the unit test for the class: " + BasicsHelper.topChrono(start, "day", "hour", "minute", "second", "millisecond", true);
				}

				CommonHelper.console(message);
				CommonHelper.console("----------------------------------------------------------------------------");
			}
		} else {
			automatedTestsStatisticsData.setInterfaces(1);
		}

		return automatedTestsStatisticsData;
	}

	/**
	 * Génération des classes de la suite des tests unitaires
	 * @throws Exception en cas d'erreur...
	 */
	@SkipTesting
	public void generateTestsSuites() throws Exception {
		CommonHelper.console((french ? "Début de la génération des suites de tests unitaires pour " : "Start of the unit test suites generation for ") + project);
		produceTestsSuites();
		CommonHelper.console((french ? "Fin de la génération des suites de tests unitaires pour " : "End of the unit test suites generation for ") + project);
	}

	/*
	 * (non-Javadoc)
	 * @see java.io.FilenameFilter#accept(java.io.File, java.lang.String)
	 */
	@Override
	public boolean accept(File dir, String name) {
		File file = new File(CommonHelper.getFullname(dir.getAbsolutePath(), name));

		if (file.isDirectory()) {
			return true;
		}

		return name.endsWith(CommonHelper.JAVA_EXTENSION);
	}

	/*
	 * (non-Javadoc)
	 * @see outils.reflexions.data.filters.ModifiersFilter#accept(int)
	 */
	@Override
	@AutomatedTests({ "Modifier.PUBLIC", "Modifier.ABSTRACT", "Modifier.PUBLIC | Modifier.ABSTRACT" })
	public boolean accept(int modifiers) {
		return Modifier.isPublic(modifiers) && !Modifier.isAbstract(modifiers);
	}
}
