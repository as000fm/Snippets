package automated.tests.helpers.base;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;

import automated.tests.annotations.AddImportsForTesting;
import automated.tests.annotations.AutomatedTests;
import automated.tests.annotations.CoverageOnly;
import automated.tests.annotations.SkipAllExceptions;
import automated.tests.annotations.StrictAutomatedTests;

/**
 * Classe des méthodes utilitaires de base de type public static final
 * @author Claude Toupin - 12 févr. 2023
 */
@SkipAllExceptions
@AddImportsForTesting(automated.tests.helpers.types.FilesCharsetsTypes.class)
public class BasicsHelper {

	/**
	 * Vérifie si deux objets sont égaux même si il y a des objects qui sont null
	 * @param object1 Le premier objet à vérifier
	 * @param object2 Le deuxième objet à vérifier
	 * @return Vrai si égaux. Note: si null et null, alors vrai
	 */
	@AutomatedTests({ "new Object[] {}", "\"Allo\"" })
	@AutomatedTests({ "new Object[] {}", "new Object[] {}" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] {}" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] { 1, 2 }" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] { 3, 4 }" })
	public static final boolean areEquals(Object object1, Object object2) {
		if ((object1 == null) && (object2 == null)) {
			return true;
		} else if ((object1 == null) || (object2 == null)) {
			return false;
		} else {
			if ((object1 instanceof Object[]) && (object2 instanceof Object[])) {
				Object[] array1 = (Object[]) object1;
				Object[] array2 = (Object[]) object2;

				if (array1.length == array2.length) {
					for (int i = 0; i < array1.length; i++) {
						if (!areEquals(array1[i], array2[i])) {
							return false;
						}
					}

					return true;
				}

				return false;
			}

			return object1.equals(object2);
		}
	}

	/**
	 * Vérifie si deux objets sont égaux (sans la case) même si il y a des objects qui sont null
	 * @param object1 Le premier objet à vérifier
	 * @param object2 Le deuxième objet à vérifier
	 * @return Vrai si égaux. Note: si null et null, alors vrai
	 */
	@AutomatedTests({ "new Object[] {}", "\"Allo\"" })
	@AutomatedTests({ "new Object[] {}", "new Object[] {}" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] {}" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] { 1, 2 }" })
	@AutomatedTests({ "new Object[] { 1, 2 }", "new Object[] { 3, 4 }" })
	public static final boolean areEqualsIgnoreCase(Object object1, Object object2) {
		if ((object1 == null) && (object2 == null)) {
			return true;
		} else if ((object1 == null) || (object2 == null)) {
			return false;
		} else {
			if ((object1 instanceof String) && (object2 instanceof String)) {
				return ((String) object1).equalsIgnoreCase((String) object2);
			}

			if ((object1 instanceof Object[]) && (object2 instanceof Object[])) {
				Object[] array1 = (Object[]) object1;
				Object[] array2 = (Object[]) object2;

				if (array1.length == array2.length) {
					for (int i = 0; i < array1.length; i++) {
						if (!areEqualsIgnoreCase(array1[i], array2[i])) {
							return false;
						}
					}

					return true;
				}

				return false;
			}

			return areEquals(object1, object2);
		}
	}

	/**
	 * Vérifie si une liste d'objets est null ou non
	 * @param objects Liste d'objets
	 * @return vrai si tous null
	 */
	public static final boolean areNulls(Object... objects) {
		if (objects != null) {
			for (Object object : objects) {
				if (object != null) {
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Création d'une liste de données sur demande à la Arrays.asList(T... a) mais pour une liste modifiable !!!
	 * @param <T> Type java des valeurs de la liste
	 * @param t Tableau de type <T> des valeurs de la liste
	 * @return une liste
	 */
	@SafeVarargs
	public static final <T> List<T> asList(T... t) {
		if (t == null) {
			return null;
		}

		List<T> list = new ArrayList<>();

		Collections.addAll(list, Arrays.copyOf(t, t.length));

		return list;
	}

	/**
	 * Traitement des strings pour eviter d'afficher un null
	 * @param value Valeur à convertir
	 * @return la string normaliser
	 */
	@AutomatedTests("new int[] { 1, 2, 3}")
	public static final String asString(Object value) {
		if (isEmpty(value)) {
			return "";
		}

		if (value.getClass().isArray()) {
			StringBuilder result = new StringBuilder();

			for (int i = 0; i < Array.getLength(value); i++) {
				if (i > 0) {
					result.append(",");
				}

				result.append(asString(Array.get(value, i)));
			}

			return result.toString();
		}

		return value.toString();
	}

	/**
	 * Compare deux objets et retourne le resultat de object1.compareTo(object2) même si null
	 * @param object1 Le premier objet à comparer
	 * @param object2 Le deuxième objet à comparer
	 * @return 0 si égale, négatif si object1 < object2, positif si object1 > object2
	 */
	@AutomatedTests(value = { "Boolean.TRUE, new java.util.Date(1583025602029L),1,1L,3.1f,3.1d, FilesCharsetsTypes.UTF_8", "Boolean.FALSE,new java.util.Date(1583025602029L),2,2L,3.2f,3.2d, FilesCharsetsTypes.AUTO_DETECTION" }, iterate = true)
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static final int compare(Object object1, Object object2) {
		Integer nulls = compareNulls(object1, object2);

		if (nulls != null) {
			return nulls.intValue();
		}

		if ((object1 instanceof String) && (object2 instanceof String)) {
			return ((String) object1).compareTo((String) object2);
		} else if ((object1 instanceof Boolean) && (object2 instanceof Boolean)) {
			return ((Boolean) object1).compareTo((Boolean) object2);
		} else if ((object1 instanceof Date) && (object2 instanceof Date)) {
			return ((Date) object1).compareTo((Date) object2);
		} else if ((object1 instanceof Integer) && (object2 instanceof Integer)) {
			return ((Integer) object1).compareTo((Integer) object2);
		} else if ((object1 instanceof Long) && (object2 instanceof Long)) {
			return ((Long) object1).compareTo((Long) object2);
		} else if ((object1 instanceof Float) && (object2 instanceof Float)) {
			return ((Float) object1).compareTo((Float) object2);
		} else if ((object1 instanceof Double) && (object2 instanceof Double)) {
			return ((Double) object1).compareTo((Double) object2);
		} else if ((object1 instanceof Enum) && (object2 instanceof Enum)) {
			return ((Enum) object1).compareTo((Enum) object2);
		}

		return asString(object1).compareTo(asString(object2)); // SC
	}

	/**
	 * Compare deux objets et retourne le resultat de object1.compareTo(object2) (sans la case) même si null
	 * @param object1 Le premier objet à comparer
	 * @param object2 Le deuxième objet à comparer
	 * @return 0 si égale, négatif si objetc1 < object2, positif si objetc1 > object2
	 */
	@AutomatedTests(value = { "Boolean.TRUE, new java.util.Date(1583025602029L),1,1L,(float) 3.1,(double) 3.1, FilesCharsetsTypes.UTF_8", "Boolean.FALSE,new java.util.Date(1583025602029L),2,2L,(float) 3.2,(double) 3.2, FilesCharsetsTypes.AUTO_DETECTION" }, iterate = true)
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static final int compareIgnoreCase(Object object1, Object object2) {
		Integer nulls = compareNulls(object1, object2);

		if (nulls != null) {
			return nulls.intValue();
		}

		if ((object1 instanceof String) && (object2 instanceof String)) {
			return ((String) object1).compareToIgnoreCase((String) object2);
		} else if ((object1 instanceof Boolean) && (object2 instanceof Boolean)) {
			return ((Boolean) object1).compareTo((Boolean) object2);
		} else if ((object1 instanceof Date) && (object2 instanceof Date)) {
			return ((Date) object1).compareTo((Date) object2);
		} else if ((object1 instanceof Integer) && (object2 instanceof Integer)) {
			return ((Integer) object1).compareTo((Integer) object2);
		} else if ((object1 instanceof Long) && (object2 instanceof Long)) {
			return ((Long) object1).compareTo((Long) object2);
		} else if ((object1 instanceof Float) && (object2 instanceof Float)) {
			return ((Float) object1).compareTo((Float) object2);
		} else if ((object1 instanceof Double) && (object2 instanceof Double)) {
			return ((Double) object1).compareTo((Double) object2);
		} else if ((object1 instanceof Enum) && (object2 instanceof Enum)) {
			return ((Enum) object1).compareTo((Enum) object2);
		}

		return asString(object1).compareToIgnoreCase(asString(object2)); // SC
	}

	/**
	 * Compare deux objets nulles (ou non) et retourne le resultat de object1.compareTo(object2) même si null
	 * @param object1 Le premier objet à comparer
	 * @param object2 Le deuxième objet à comparer
	 * @return 0 si nulles, négatif si object1 est null, positif si object2 est null, null sinon (i.e. non nulles)
	 */
	public static final Integer compareNulls(Object object1, Object object2) {
		if ((object1 == null) && (object2 == null)) {
			return 0;
		} else if (object1 == null) {
			return -1;
		} else if (object2 == null) {
			return 1;
		}

		return null;
	}

	/**
	 * Effectue la conversion en "CamelCase" (ou "CamelBack") ex: allo_toto -> AlloToto (si uppercase == true)
	 * @param uppercase Indique si la première lettre doit être en majuscule
	 * @param value La valeur à traiter
	 * @return la valeur convertie
	 */
	@AutomatedTests(value = { "false,true", "allo_toto" }, iterate = true)
	public static final String doCamelCase(boolean uppercase, String value) {
		StringBuilder sb = new StringBuilder();

		if (!isEmpty(value)) {
			char[] charsData = value.toCharArray();

			boolean hasSeparator = false;

			for (int i = 0; i < charsData.length; i++) {
				char c = charsData[i];

				if (!Character.isLetterOrDigit(c)) {
					uppercase = true;
					hasSeparator = true;
				} else if ((i == 0) || hasSeparator) {
					sb.append(uppercase ? Character.toUpperCase(c) : Character.toLowerCase(c));
					uppercase = false;
					hasSeparator = false;
				} else {
					sb.append(c);
				}
			}
		}

		return sb.toString();
	}

	/**
	 * Effectue la capitalisation du texte (i.e. mettre la première lettre du début de la phrase en majuscule)
	 * @param value La valeur à traiter
	 * @return la valeur convertie
	 */
	@AutomatedTests("a")
	public static final String doCapitalize(String value) {
		if (!isEmpty(value)) {
			if (value.length() == 1) {
				return value.toUpperCase();
			}

			return value.substring(0, 1).toUpperCase() + value.substring(1);
		}

		return value;
	}

	/**
	 * Harmonisation du texte afin d'éviter d'avoir 2 lettres en majuscules qui se suivent. ex: MAJAlloToto -> MajAlloToto
	 * @param value La valeur à harmoniser
	 * @return la valeur harmonisée
	 */
	@AutomatedTests({ "MAJAlloToto", "MAJ\\Allo/Toto" })
	public static final String doHarmonization(String value) {
		if (!isEmpty(value)) {
			char[] charsData = value.toCharArray();

			int count = 0;

			for (int i = 0; i < charsData.length; i++) {
				char c = charsData[i];

				if (Character.isLetterOrDigit(c)) {
					if (Character.isUpperCase(c)) {
						if (count != 0) {
							charsData[i] = Character.toLowerCase(c);
						}

						count++;
					} else {
						if (count > 1) {
							charsData[i - 1] = Character.toUpperCase(charsData[i - 1]);
						}

						count = 0;
					}
				} else if ((c == '\\') || (c == '/')) {
					count = 0;
				}
			}

			return new String(charsData);
		}

		return value;
	}

	/**
	 * Effectue la décapitalisation du texte (i.e. mettre la première lettre du début de la phrase en minuscule)
	 * @param value La valeur à traiter
	 * @return la valeur convertie
	 */
	@AutomatedTests("A")
	public static final String doUncapitalize(String value) {
		if (!isEmpty(value)) {
			if (value.length() == 1) {
				return value.toLowerCase();
			}

			return value.substring(0, 1).toLowerCase() + value.substring(1);
		}

		return value;
	}

	/**
	 * Effectue un nombre de copie d'une valeur donnée
	 * @param value La valeur initiale à recopier
	 * @param count Le nombre de copies à effectuer
	 * @return le texte de la copie
	 */
	@AutomatedTests({ "\"Test\"", "2" })
	public static final String duplicate(Object value, int count) {
		String source = asString(value);

		if (isEmpty(source)) {
			return source;
		}

		StringBuilder result = new StringBuilder();
		result.append(source);

		while (count > 0) {
			result.append(source);
			count--;
		}

		return result.toString();
	}

	/**
	 * Extrait le temps d'exécution
	 * @param runtime Le temps d'exécution en millisecondes
	 * @param days Séparateur du jours (null -> en heures seulement)
	 * @param hours Séparateur des heures (null -> ne pas afficher)
	 * @param minutes Séparateur des minutes (null -> ne pas afficher)
	 * @param seconds Séparateur des secondes (null -> ne pas afficher)
	 * @param milli Séparateur des millisecondes (null -> ne pas afficher)
	 * @param plurial Indicateur de pluriel
	 * @return un String
	 */
	public static final String duration(long runtime, String days, String hours, String minutes, String seconds, String milli, boolean plurial) {
		return duration(runtime, days, hours, minutes, seconds, milli, plurial, false);
	}

	/**
	 * Extrait le temps d'exécution
	 * @param runtime Le temps d'exécution en millisecondes
	 * @param days Séparateur du jours (null -> en heures seulement)
	 * @param hours Séparateur des heures (null -> ne pas afficher)
	 * @param minutes Séparateur des minutes (null -> ne pas afficher)
	 * @param seconds Séparateur des secondes (null -> ne pas afficher)
	 * @param milli Séparateur des millisecondes (null -> ne pas afficher)
	 * @param plurial Indicateur de pluriel
	 * @param complete Indicateur de temps complet incluant les unités à zéro (ex: 1 heure 0 minutes 0 seconde 0 milliseconde)
	 * @return un String
	 */
	@AutomatedTests(value = { "-1,0,99,720000,36000000,86400001,180122100", "day", "hour", "minute", "second", "milli", "false,true", "false,true" }, iterate = true)
	public static final String duration(long runtime, String days, String hours, String minutes, String seconds, String milli, boolean plurial, boolean complete) {
		if (runtime < 0) {
			runtime = -1 * runtime;
		}

		// jours (24 * 60 * 60 * 1000 -> 86400000)
		long daysValue = runtime / 86400000;
		runtime %= 86400000;

		// heures (60 * 60 * 1000 -> 3600000)
		long hoursValue = runtime / 3600000;
		runtime %= 3600000;

		// minutes (60 * 1000 -> 60000)
		long minutesValue = runtime / 60000;
		runtime %= 60000;

		// secondes (1000)
		long secondsValue = runtime / 1000;
		runtime %= 1000;

		// millisecondes
		long milliValue = runtime;
		runtime = 0; // Pour la forme...

		boolean sequence = false;

		StringBuilder sb = new StringBuilder();

		// jours
		if ((days != null) && ((daysValue > 0) || complete)) {
			sequence = true;

			sb.append(daysValue);

			if (plurial) {
				sb.append(' ');
				sb.append(days);
				sb.append((daysValue > 1) ? "s " : " ");
			} else {
				sb.append(days);
			}
		}

		// heures
		if ((hours != null) && ((hoursValue > 0) || complete)) {
			if (sequence && !plurial) {
				if (hoursValue < 10) {
					sb.append('0');
				}
			}

			sequence = true;

			sb.append(hoursValue);

			if (plurial) {
				sb.append(' ');
				sb.append(hours);
				sb.append((hoursValue > 1) ? "s " : " ");
			} else {
				sb.append(hours);
			}
		}

		// minutes
		if ((minutes != null) && ((minutesValue > 0) || complete)) {
			if (sequence && !plurial) {
				if (minutesValue < 10) {
					sb.append('0');
				}
			}

			sequence = true;

			sb.append(minutesValue);

			if (plurial) {
				sb.append(' ');
				sb.append(minutes);
				sb.append((minutesValue > 1) ? "s " : " ");
			} else {
				sb.append(minutes);
			}
		}

		// secondes
		if ((seconds != null) && ((secondsValue > 0) || complete)) {
			if (sequence && !plurial) {
				if (secondsValue < 10) {
					sb.append('0');
				}
			}

			sequence = true;

			sb.append(secondsValue);

			if (plurial) {
				sb.append(' ');
				sb.append(seconds);
				sb.append((secondsValue > 1) ? "s " : " ");
			} else {
				sb.append(seconds);
			}
		}

		// millisecondes
		if ((milli != null) && ((milliValue > 0) || complete)) {
			if (sequence && !plurial) {
				if (milliValue < 10) {
					sb.append("00");
				} else if (milliValue < 100) {
					sb.append('0');
				}
			}

			sequence = true;

			sb.append(milliValue);

			if (plurial) {
				sb.append(' ');
				sb.append(milli);
				sb.append((milliValue > 1) ? "s " : " ");
			} else {
				sb.append(milli);
			}
		}

		return sb.toString().trim();
	}

	/**
	 * Détermine si la valeur débute par un préfixe donné même si null
	 * @param value Valeur à vérifier
	 * @param suffix Suffixe à terminer pas
	 * @return Vrai si se termine par le suffixe donné
	 */
	public static final boolean endsWith(String value, String suffix) {
		if (!isEmpty(value) && !isEmpty(suffix)) {
			return value.endsWith(suffix);
		}

		return false;
	}

	/**
	 * Retourne la liste sous forme de pairs séparés par un séparateur
	 * @param list Liste des données
	 * @param separator Le séparateur entre chaque élément
	 * @return la liste sous forme d'un StringBuilder
	 */
	@AutomatedTests({ "1,,2", "," })
	public static final StringBuilder getStringBuilderList(List<?> list, String separator) {
		StringBuilder result = new StringBuilder();

		if (list != null) {
			for (int i = 0; i < list.size(); i++) {
				if (i > 0) {
					result.append(separator);
				}

				Object obj = list.get(i);

				if (obj != null) {
					result.append(obj.toString());
				}
			}
		}

		return result;
	}

	/**
	 * Retourne la liste sous forme de pairs séparés par un séparateur
	 * @param list Liste des données
	 * @param separator Le séparateur entre chaque élément
	 * @param between Mettre chaque élément entre deux strings spécifiques
	 * @return la liste sous forme d'un StringBuilder
	 */
	@AutomatedTests({ "1,,2", ",", "|" })
	public static final StringBuilder getStringBuilderList(List<?> list, String separator, String between) {
		StringBuilder result = new StringBuilder();

		if (list != null) {
			for (int i = 0; i < list.size(); i++) {
				if (i > 0) {
					result.append(separator);
				}

				result.append(between);

				Object obj = list.get(i);

				if (obj != null) {
					result.append(obj.toString());
				}

				result.append(between);
			}
		}

		return result;
	}

	/**
	 * Transforme un int en String
	 * @param value Le int a transformer
	 * @return un String
	 */
	public static final String intToString(int value) {
		return (Integer.valueOf(value)).toString();
	}

	/**
	 * Verifie si l'objet est nulle
	 * @param value Valeur à vérifier
	 * @return Vrai si nulle
	 */
	@AutomatedTests({ "new java.util.ArrayList<String>()", "new java.util.HashMap<String, String>()", "new int[0]", "new int[1]" })
	public static final boolean isEmpty(Object value) {
		if (value != null) {
			if (value instanceof String) {
				return ((String) value).isEmpty();
			} else if (value instanceof Collection<?>) {
				return ((Collection<?>) value).isEmpty();
			} else if (value instanceof Map<?, ?>) {
				return ((Map<?, ?>) value).isEmpty();
			} else if (value.getClass().isArray()) {
				return Array.getLength(value) == 0;
			}

			return false;
		}

		return true;
	}

	/**
	 * Détermine si la valeur est impair ou non
	 * @param value La valeur à déterminer
	 * @return vrai si impair
	 */
	@AutomatedTests({ "1", "2" })
	public static final boolean isOdd(int value) {
		return (value % 2) != 0;
	}

	/**
	 * Agrandit le texte d'un objetjusqu'à la longueur spécifié en ajoutant le caractère spécifié au début du texte
	 * @param source L'objet à agrandir
	 * @param padChar Le caractère à utiliser pour au début du texte
	 * @param length La longueur total
	 * @return le texte à la longueur spécifiée
	 */
	public static final String padString(Object value, char padChar, int length) {
		String source = asString(value);

		StringBuilder result = new StringBuilder();

		int nb = length - source.length();

		while (nb > 0) {
			result.append(padChar);
			nb--;
		}

		result.append(source);

		return result.toString();
	}

	/**
	 * Découpe une ligne csv en liste des valeurs
	 * @param line La ligne csv
	 * @param separator Type de séparateur
	 * @return la liste des valeurs
	 */
	public static final String[] parseRowAsArray(String line, char separator) {
		List<String> values = parseRowAsList(line, separator);

		return values.toArray(new String[values.size()]);
	}

	/**
	 * Découpe une ligne csv en liste des valeurs
	 * @param line La ligne csv
	 * @param separator Type de séparateur
	 * @param escapeQuotes Indicateur de supressions des guillemets
	 * @return la liste des valeurs
	 */
	public static final String[] parseRowAsArray(String line, char separator, boolean escapeQuotes) {
		List<String> values = parseRowAsList(line, separator, escapeQuotes);

		return values.toArray(new String[values.size()]);
	}

	/**
	 * Découpe une ligne csv en liste des valeurs
	 * @param line La ligne csv
	 * @param separator Type de séparateur
	 * @return la liste des valeurs
	 */
	public static final List<String> parseRowAsList(String line, char separator) {
		return parseRowAsList(line, separator, false);
	}

	/**
	 * Découpe une ligne csv en liste des valeurs
	 * @param line La ligne csv
	 * @param separator Type de séparateur
	 * @param escapeQuotes Indicateur de supressions des guillemets
	 * @return la liste des valeurs
	 */
	public static final List<String> parseRowAsList(String line, char separator, boolean escapeQuotes) {
		List<String> values = new ArrayList<>();

		if (!BasicsHelper.isEmpty(line)) {
			char[] charsData = line.toCharArray();

			int current = 0;
			int start = 0;
			boolean skip = false;

			while (current < charsData.length) {
				if (!skip) {
					skip = (charsData[current] == '"');
				} else {
					if (charsData[current] == '"') {
						skip = false;
					}
				}

				if (skip) {
					current++;
				} else {
					if (charsData[current] == separator) {
						if (start == current) {
							values.add(null);
						} else {
							StringBuilder sb = new StringBuilder();

							for (int i = start; i < current; i++) {
								sb.append(charsData[i]);
							}

							String s = sb.toString();

							if (escapeQuotes) {
								if (s.contains("\"")) {
									s = s.trim();
								}

								if (s.startsWith("\"") && s.endsWith("\"")) {
									s = s.substring(1, s.length() - 1);
								}

								s = s.replace("\"\"", "\"");
							}

							values.add(s);
						}

						current++;
						start = current;
					} else {
						current++;
					}
				}
			}

			if (start == current) {
				values.add(null);
			} else {
				StringBuilder sb = new StringBuilder();

				for (int i = start; i < current; i++) {
					sb.append(charsData[i]);
				}

				String s = sb.toString();

				if (escapeQuotes) {
					if (s.contains("\"")) {
						s = s.trim();
					}

					if (s.startsWith("\"") && s.endsWith("\"")) {
						s = s.substring(1, s.length() - 1);
					}

					s = s.replace("\"\"", "\"");
				}

				values.add(s);
			}
		}

		return values;
	}

	/**
	 * Extrait le pluriel selon la taille
	 * @param size La taille
	 * @return le singulier ou le pluriel selon la taille
	 */
	@AutomatedTests("2")
	public static final String plural(int size) {
		if (size > 1) {
			return "s";
		}

		return "";
	}

	/**
	 * Extrait un message au pluriel selon la taille
	 * @param size La taille
	 * @param singularTexts Liste de textes au singulier
	 * @return le message au singulier ou au pluriel selon la taille
	 */
	@AutomatedTests({ "2", "A,B" })
	public static final String plural(int size, String... singularTexts) {
		String message = "";

		for (String singularText : singularTexts) {
			if (!isEmpty(message)) {
				message += " ";
			}

			message += asString(singularText).trim() + plural(size);
		}

		return message;
	}

	/**
	 * Extrait un message au pluriel selon la taille
	 * @param size La taille
	 * @param singularTexts Liste de textes au singulier
	 * @return le message au singulier ou au pluriel selon la taille
	 */
	@AutomatedTests({ "2", "A,B" })
	public static final String pluralSize(int size, String... singularTexts) {
		StringBuilder message = new StringBuilder(asString(size));

		for (String singularText : singularTexts) {
			message.append(" " + asString(singularText).trim() + plural(size));
		}

		return message.toString();
	}

	/**
	 * Remplace tous les occurrences d'un texte avec une autre
	 * @param value Le texte à traiter
	 * @param oldString Le texte à remplacer
	 * @param newString Le texte de remplacement
	 * @return le texte traité
	 */
	public static final String replace(String value, String oldString, String newString) {
		if (isEmpty(value) || isEmpty(oldString)) {
			return value;
		}

		newString = asString(newString);

		String resultat = value;

		int oldLen = oldString.length();
		int newLen = newString.length();

		int pos = resultat.indexOf(oldString);

		while (pos != -1) {
			StringBuilder sb = new StringBuilder(resultat.substring(0, pos));
			sb.append(newString);
			sb.append(resultat.substring(pos + oldLen));
			resultat = sb.toString();
			pos = resultat.indexOf(oldString, pos + newLen);
		}

		return resultat;
	}

	/**
	 * Détermine si la valeur débute par un préfixe donné même si null
	 * @param value Valeur à vérifier
	 * @param prefix Pérfixe à débuter pas
	 * @return Vrai si débute par le préfixe donné
	 */
	public static final boolean startsWith(String value, String prefix) {
		if (!isEmpty(value) && !isEmpty(prefix)) {
			return value.startsWith(prefix);
		}

		return false;
	}

	/**
	 * Détermine si la valeur débute par un préfixe donné (sans la case) même si null
	 * @param value Valeur à vérifier
	 * @param prefix Préfixe à débuter pas
	 * @return Vrai si débute par le préfixe donné
	 */
	public static final boolean startsWithIgnoreCase(String value, String prefix) {
		if (!isEmpty(value) && !isEmpty(prefix)) {
			return value.toUpperCase().startsWith(prefix.toUpperCase());
		}

		return false;
	}

	/**
	 * Convertit un chaîne sans accents
	 * @param value La chaîne à convertir
	 * @return la chaîne convertit
	 */
	@AutomatedTests("ÀÁÂÃÄÅÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåçèéêëìíîïðñòóôõöøùúûüýÿ\u00d7")
	public static final String toEnglish(String value) {
		if (value == null) {
			return null;
		}

		char[] charsData = value.toCharArray();

		for (int i = 0; i < charsData.length; i++) {
			char c = charsData[i];

			if ((c >= '\u00c0') && (c <= '\u00c5')) {
				charsData[i] = 'A';
			} else if (c == '\u00c7') {
				charsData[i] = 'C';
			} else if ((c >= '\u00c8') && (c <= '\u00cb')) {
				charsData[i] = 'E';
			} else if ((c >= '\u00cc') && (c <= '\u00cf')) {
				charsData[i] = 'I';
			} else if (c == '\u00d0') {
				charsData[i] = 'D';
			} else if (c == '\u00d1') {
				charsData[i] = 'N';
			} else if ((c >= '\u00d2') && (c <= '\u00d6')) {
				charsData[i] = 'O';
			} else if (c == '\u00d7') {
				charsData[i] = 'x';
			} else if (c == '\u00d8') {
				charsData[i] = 'o';
			} else if ((c >= '\u00d9') && (c <= '\u00dc')) {
				charsData[i] = 'U';
			} else if (c == '\u00dd') {
				charsData[i] = 'Y';
			} else if (c == '\u00df') {
				charsData[i] = 'B';
			} else if ((c >= '\u00e0') && (c <= '\u00e5')) {
				charsData[i] = 'a';
			} else if (c == '\u00e7') {
				charsData[i] = 'c';
			} else if ((c >= '\u00e8') && (c <= '\u00eb')) {
				charsData[i] = 'e';
			} else if ((c >= '\u00ec') && (c <= '\u00ef')) {
				charsData[i] = 'i';
			} else if (c == '\u00f0') {
				charsData[i] = 'o';
			} else if (c == '\u00f1') {
				charsData[i] = 'n';
			} else if ((c >= '\u00f2') && (c <= '\u00f6')) {
				charsData[i] = 'o';
			} else if (c == '\u00f8') {
				charsData[i] = 'o';
			} else if ((c >= '\u00f9') && (c <= '\u00fc')) {
				charsData[i] = 'u';
			} else if (c == '\u00fd') {
				charsData[i] = 'y';
			} else if (c == '\u00ff') {
				charsData[i] = 'y';
			}
		}

		return new String(charsData);
	}

	/**
	 * Retourne la liste sous forme de pairs séparés par un séparateur
	 * @param list Liste des données
	 * @param separator Le séparateur entre chaque élément
	 * @return la liste sous forme d'une string
	 */
	@AutomatedTests({ "1,2,3", ";" })
	public static final String toList(List<?> list, String separator) {
		return getStringBuilderList(list, separator).toString();
	}

	/**
	 * Retourne la liste sous forme de pairs séparés par un séparateur
	 * @param list Liste des données
	 * @param separator Le séparateur entre chaque élément
	 * @param between Mettre chaque élément entre deux strings spécifiques
	 * @return la liste sous forme d'une string
	 */
	@AutomatedTests({ "1,2,3", ";", "$" })
	public static final String toList(List<?> list, String separator, String between) {
		return getStringBuilderList(list, separator, between).toString();
	}

	/**
	 * Extrait le temps d'exécution sous forme jj hh:mm:ss.ms
	 * @param start Le début de l'exécution
	 * @param days Séparateur du jours (null -> en heures seulement)
	 * @param hours Séparateur des heures (null -> ne pas afficher)
	 * @param minutes Séparateur des minutes (null -> ne pas afficher)
	 * @param seconds Séparateur des secondes (null -> ne pas afficher)
	 * @param milli Séparateur des millisecondes (null -> ne pas afficher)
	 * @param plurial Indicateur de pluriel
	 * @return un String
	 */
	@CoverageOnly
	@StrictAutomatedTests(value = { "System.currentTimeMillis()", "day", "hour", "minute", "second", "milli", "false,true" }, iterate = true)
	public static final String topChrono(long start, String days, String hours, String minutes, String seconds, String milli, boolean plurial) {
		return duration(System.currentTimeMillis() - start, days, hours, minutes, seconds, milli, plurial);
	}

}
